# package dep

## Open Questions:

- Q: How do identify stale entries that should be pruned?
  A: We do not need this, since we do not modify a DB, we only build
     them, which means everything acts in an 'appending/additive' manner.
- Q: At what level do we do the dependency tracking for a single DB?
  A: We do it at the library/executable level. So each library or
     executable has its own dependency DB, which contains the dependencies 
     for that library or executable.
     This also means that we can compile a library or executable in isolation,
     and thus in parallel.
     We already have a toolchain instance per project, where each project is
     either a library or an executable, so this is a natural fit.

## Design and Implementation Notes:

- Fully custom 
- Written in pure Go
- No external dependencies

## Design and Implementation Notes:

- We load the DB from disk and use it to query the state of a file, in 
  the meantime we also create a new DB that we use to register files 
  and their dependencies, this is the new DB.
  The new one becomes the main DB when we save it, and we delete the
  previous DB. On the next run, we load the new DB from disk and use it to
  query the state of a file.
- When nothing has changed, we do not write the new DB to disk.
- The largest part of the DB is the Data array, it contains all the item
  data (filepaths) with a lot of duplication, so it should be a very good 
  candidate for compression. Something like `snappy` from the standard 
  library would likely compress this data very well.
  Furthermore, the Shards array is also a very good candidate for compression.

## Dependency Tracking General Information:

- Executable: depends on archives
- Archive: depends on object files, command line arguments, etc.
- Object file: depends on source file
- Source file: depends on header files, source files, command line arguments, etc.

The purpose of dependency tracking is to not compile an executable, archive or 
source file if it and all of its dependencies have not changed.

GCC and other compilers generate a .d file that contains the dependencies of
a source file. The .d file is generated by the compiler and contains the
dependencies of the source file.

Microsoft Visual Studio now has a similar mechanism, where it can generate a file
that contains the dependencies of a source file, it does have a different format
since it is saved as JSON.

A dependency represents the dependency description of:

- a file (.cpp, .c, .lib, .a, .exe, etc..)
- a command line argument (e.g. MSVC C++ compiler cmd-line arguments)
- a version of something (e.g. Visual Studio, GCC, Arduino, etc..)

## User API

- Load(dirpath)
  Load DBs from disk (use load point, when Ok, delete previous save point(s))
- Save(dirpath)
  Save DBs to disk (use save point)
- Register(string file, string[] deps)
  Register a file and its dependencies
- Query a file and return the state (up-to-date, out-of-date).
  As a debugging feature, return []*Item that have contributed to the
  out-of-date state.

Note: The hash of data for Item ID should be different from the hash of the
      the same data for Item ID that is attached to a Dep.
      We could do this by prefixing the data with 'src' for Item and 'dep' for
      Dep, before generating the digest.

## Data Structures

We use 'soa' (structure of arrays) to store the data, this is because we want to
have a single array for each field, this allows us to simplify the loading and
saving of the data, and since we mainly use indexing and no pointers, we also do
not have to do anything when we load the data from disk.
