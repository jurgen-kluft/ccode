# package dep

## Open Questions:

- Q: How do identify stale entries that should be pruned?
  A: We do not need this, since we do not modify a DB, we only build
     them, which means everything acts in an 'appending/additive' manner.

## Design and Implementation Notes:

- Fully custom 
- Written in pure Go
- No external dependencies

## Design and Implementation Notes:

- We load the DB from disk and use it to query the state of a file, in 
  the meantime we also create a new DB that we use to register files 
  and their dependencies, this is the new DB.
  The new one becomes the main DB when we save it, and we delete the
  previous DB. On the next run, we load the new DB from disk and use it to
  query the state of a file.
- When nothing has changed, we do not write the new DB to disk.

## Dependency Tracking General Information:

- Executable: depends on archives
- Archive: depends on object files, command line arguments, etc.
- Object file: depends on source file
- Source file: depends on header files, source files, command line arguments, etc.

The purpose of dependency tracking is to not compile an executable, archive or 
source file if it and all of its dependencies have not changed.

GCC and other compilers generate a .d file that contains the dependencies of
a source file. The .d file is generated by the compiler and contains the
dependencies of the source file.
Microsoft Visual Studio has a similar mechanism, where it can generate a file
that contains the dependencies of a source file, it does have a different format
since it is saved as JSON.

A dependency represents the dependency description of:

- a file (.cpp, .c, .lib, .a, .exe, etc..)
- a command line argument (e.g. MSVC C++ compiler cmd-line arguments)
- a version of something (e.g. Visual Studio, GCC, Arduino, etc..)

## User API

- Load(dirpath)
  Load DBs from disk (use load point, when Ok, delete previous save point(s))
- Save(dirpath)
  Save DBs to disk (use save point)
- Register(string file, string[] deps)
  Register a file and its dependencies
- Query a file and return the state (up-to-date, out-of-date).
  As a debugging feature, return []*Item that have contributed to the
  out-of-date state.

Note: The hash of data for Item ID should be different from the hash of the
      the same data for Item ID that is attached to a Dep.
      We could do this by prefixing the data with 'src' for Item and 'dep' for
      Dep, before generating the digest.

## item db

Item (16 bytes) (shared)

- int32, index to Hash-Node, this is the ID of the item (filepath, label (e.g. 'MSVC C++ compiler cmd-line arguments))
- int32, index to Hash-Node, this identifies the 'change' (modification-time, file-size, file-content, command-line arguments, string, etc..)
- int32, start into global array of []uint32, this is the global array of dependency indices
- int32, number of dependencies

## hash db

Hash Node (32 bytes) (unique)

- hash (byte[20])
- uint32, index to Data
- uint32, index to Item
- uint32, flags

## data db

Data

- aligned to 8 bytes
- has a length prefix of uint32
- `[length][bytes[length]]{padding}`
