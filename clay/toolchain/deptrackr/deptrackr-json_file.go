package deptrackr

import (
	"bytes"
	"crypto/sha1"
	"encoding/binary"
	"fmt"
	"hash"
	"os"
	"strings"
	"time"
)

// The depFileTracker is using the output of compilers like gcc,
// clang, etc. It uses the .d files generated by these compilers.
type jsonFileTracker struct {
	current      *trackr
	currentState State
	future       *trackr
	hasher       hash.Hash
}

func LoadJsonFileTrackr(storageFilepath string) FileTrackr {
	current := loadTrackr(storageFilepath, "file deptrackr, v1.0.4")
	tracker := current.newTrackr()
	return &jsonFileTracker{
		current:      current,
		currentState: StateUpToDate, // Start with an up-to-date state
		future:       tracker,
		hasher:       sha1.New(),
	}
}

func (d *jsonFileTracker) Save() (int, error) {
	if d.currentState == StateUpToDate {
		// If the current state is up to date, we do not need to save anything
		return 0, nil
	}
	err := d.future.save()
	return 1, err
}

// The format of the dependency information that is generated by msvc compiler is:
// https://learn.microsoft.com/en-us/cpp/build/reference/sourcedependencies?view=msvc-170#examples

/* Example: callocator/source/test/cpp/test_allocator_cs.cpp
{
    "Version": "1.2",
    "Data": {
        "Source": "d:\\dev.go\\src\\github.com\\jurgen-kluft\\callocator\\source\\test\\cpp\\test_allocator_cs.cpp",
        "ProvidedModule": "",
        "Includes": [
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\ccore\\source\\main\\include\\ccore\\c_allocator.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\ccore\\source\\main\\include\\ccore\\c_target.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\ccore\\source\\main\\include\\ccore\\config\\c_compiler.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\ccore\\source\\main\\include\\ccore\\config\\c_compiler_traits.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\ccore\\source\\main\\include\\ccore\\config\\c_platform.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\ccore\\source\\main\\include\\ccore\\c_debug.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\callocator\\source\\main\\include\\callocator\\c_allocator_cs.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\cunittest.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_config.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_utils.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_file.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_test.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_testresults.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_testmacros.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_checkmacros.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_checks.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_stringbuilder.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_exception.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_reportassert.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_testreporterstdout.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_testreporter.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_stdout.h",
            "d:\\dev.go\\src\\github.com\\jurgen-kluft\\cunittest\\source\\main\\include\\cunittest\\private\\ut_testreporterteamcity.h"
        ],
        "ImportedModules": [],
        "ImportedHeaderUnits": []
    }
}
*/

func ParseJsonDependencyFile(filepath string) (mainItem string, depItems []string, err error) {
	contentBytes, err := os.ReadFile(filepath)
	if err != nil {
		return "", []string{}, err
	}

	type part struct {
		from int
		to   int
	}

	// Parse the .d file content
	content := string(contentBytes)
	var parts []part

	startPos := strings.Index(content, "Includes\":")
	if startPos == -1 {
		return "", []string{}, fmt.Errorf("invalid dependency file format: %s", filepath)
	}
	startPos += len("Includes\":") // Move to the start of the includes array

	endPos := strings.Index(content[startPos:], "]")
	if endPos == -1 {
		return "", []string{}, fmt.Errorf("invalid dependency file format: %s", filepath)
	}
	endPos += startPos // Adjust end position to the correct index in the content

	for startPos < endPos {

		begin := strings.Index(content[startPos:], "\"")
		if begin == -1 {
			break
		}
		begin += startPos + 1

		end := strings.Index(content[begin:], "\"")
		if end == -1 {
			break // No closing quote found
		}
		end += begin // Adjust end position to the correct index in the content

		parts = append(parts, part{from: begin, to: end})

		startPos = end + 1 // Move to the next part after the closing quote

		begin = strings.Index(content[startPos:], "\"")
		if begin == -1 {
			break // No more parts found
		}
		startPos += begin
	}

	for i, p := range parts {
		if i == 0 {
			mainItem = content[p.from:p.to]
		} else {
			depItem := content[p.from:p.to]
			depItems = append(depItems, depItem)
		}
	}

	return mainItem, depItems, nil
}

func (d *jsonFileTracker) CopyItem(item string) {
	d.hasher.Reset()
	d.hasher.Write([]byte(item))
	itemHash := d.hasher.Sum(nil)
	d.current.CopyItem(d.future, itemHash)
}

// item = depfileAbsFilepath
func (d *jsonFileTracker) addItem(item string, extra []byte, deps []string) error {

	// ----------------------------------------------------------------
	d.hasher.Reset()
	d.hasher.Write([]byte(item))
	mainHash := d.hasher.Sum(nil)

	// For the 'change', we want the file modification time and hash it
	modTimeBytes := make([]byte, 8)
	fileInfo, err := os.Stat(item)
	if err != nil {
		binary.LittleEndian.PutUint64(modTimeBytes, uint64(time.Now().Unix())) // If the file does not exist, use the current time
	} else {
		binary.LittleEndian.PutUint64(modTimeBytes, uint64(fileInfo.ModTime().Unix()))
	}

	// We are adding a new item, so the trackr is marked as out of date
	d.currentState = StateOutOfDate

	itemToAdd := ItemToAdd{
		IdData:       []byte(item),
		IdDigest:     mainHash,
		IdFlags:      ItemFlagSourceFile,
		ChangeData:   bytes.Clone(modTimeBytes),
		ChangeDigest: nil, // mod-time is small enough, we do not need a hash
		ChangeFlags:  ChangeFlagModTime,
	}

	var depItems []ItemToAdd
	for _, depFilepath := range deps {
		// Make sure the digest of a dependency will be unique and
		// not identical when the same file is used as a main item
		d.hasher.Reset()
		d.hasher.Write([]byte{'d', 'e', 'p'})
		d.hasher.Write([]byte(depFilepath))
		depDigest := d.hasher.Sum(nil)

		// For the 'change', we want the file modification time and hash it
		fileInfo, err = os.Stat(depFilepath)
		if err != nil {
			binary.LittleEndian.PutUint64(modTimeBytes, uint64(time.Now().Unix()))
		} else {
			binary.LittleEndian.PutUint64(modTimeBytes, uint64(fileInfo.ModTime().Unix()))
		}

		depItemToAdd := ItemToAdd{
			IdDigest:     depDigest,
			IdData:       []byte(depFilepath),
			IdFlags:      ItemFlagDependency,
			ChangeDigest: nil, // mod-time is small enough, we do not need a hash
			ChangeData:   bytes.Clone(modTimeBytes),
			ChangeFlags:  ChangeFlagModTime,
		}
		depItems = append(depItems, depItemToAdd)
	}
	if len(extra) == 0 {
		d.future.AddItem(itemToAdd, depItems)
	} else {
		d.future.AddItemWithExtraData(itemToAdd, extra, depItems)
	}
	return nil
}

func (d *jsonFileTracker) AddItem(item string, deps []string) error {
	return d.addItem(item, nil, deps)
}

// QueryFile checks if the files are up to date, returning true if it is,
// or false if it is out of date or does not exist in the current state.
func (d *jsonFileTracker) QueryItem(item string) bool {
	d.hasher.Reset()
	d.hasher.Write([]byte(item))
	mainDigest := d.hasher.Sum(nil)

	modTimeBytes := make([]byte, 8) // 8 bytes for the file modification time

	state, err := d.current.QueryItem(mainDigest, true, func(itemState State, itemIdFlags uint8, itemIdData []byte, itemChangeFlags uint8, itemChangeData []byte) State {
		if itemIdFlags&ItemFlagSourceFile == ItemFlagSourceFile || itemIdFlags&ItemFlagDependency == ItemFlagDependency {
			// Items that have been gone through a query have been updated with their current state which
			// was either up to date or out of date. This avoids asking the filesystem for the state of the file
			// if it is already known to be up to date or out of date.
			// This is mainly relevant for dependency files, which can be shared between multiple main items.
			if itemState == StateNone {
				srcFileInfo, err := os.Stat(string(itemIdData))
				if err == nil {
					binary.LittleEndian.PutUint64(modTimeBytes, uint64(srcFileInfo.ModTime().Unix()))
					if bytes.Compare(modTimeBytes, itemChangeData) == 0 {
						return StateUpToDate
					}
				}
				return StateOutOfDate
			}
			return itemState
		} else {
			// TODO, handle other types of items (StringItem)
			return StateUpToDate
		}
	})

	if err != nil {
		fmt.Println("Error querying item:", err)
	}

	return state == StateUpToDate
}

func (d *jsonFileTracker) AddItemWithExtraData(item string, data []byte, deps []string) error {
	return d.addItem(item, data, deps)
}

func (d *jsonFileTracker) QueryItemWithExtraData(item string, data []byte) bool {
	d.hasher.Reset()
	d.hasher.Write([]byte(item))
	mainDigest := d.hasher.Sum(nil)

	modTimeBytes := make([]byte, 8) // 8 bytes for the file modification time

	state, err := d.current.QueryItemExtra(mainDigest, true, func(itemState State, itemIdFlags uint8, itemIdData []byte, itemExtraData []byte, itemChangeFlags uint8, itemChangeData []byte) State {
		if itemIdFlags&ItemFlagSourceFile == ItemFlagSourceFile || itemIdFlags&ItemFlagDependency == ItemFlagDependency {
			// Items that have been gone through a query have been updated with their current state which
			// was either up to date or out of date. This avoids asking the filesystem for the state of the file
			// if it is already known to be up to date or out of date.
			// This is mainly relevant for dependency files, which can be shared between multiple main items.
			if itemState == StateNone {
				// Check if the itemExtraData matches the item extra data we are querying
				// Note: dependency items do not have extra data (nil or zero size)
				if len(itemExtraData) == 0 || bytes.Equal(itemExtraData, data) {
					srcFileInfo, err := os.Stat(string(itemIdData))
					if err == nil {
						binary.LittleEndian.PutUint64(modTimeBytes, uint64(srcFileInfo.ModTime().Unix()))
						if bytes.Compare(modTimeBytes, itemChangeData) == 0 {
							return StateUpToDate
						}
					}
				}
				return StateOutOfDate
			}
			return itemState
		} else {
			// TODO, handle other types of items (StringItem)
			return StateUpToDate
		}
	})

	if err != nil {
		fmt.Println("Error querying item:", err)
	}

	return state == StateUpToDate
}
