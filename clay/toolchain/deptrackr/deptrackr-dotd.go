package deptrackr

import (
	"crypto/sha1"
	"encoding/binary"
	"fmt"
	"hash"
	"os"
	"strings"
	"time"
)

// Note: For archives and executables, the toolchain is required to write out a .d file that
//       contains the dependencies of the archive or executable file.

// String Item is used to represent a string item in the depTrackr.
// Examples:
//   - Linker commandline:
//     -) Label: "Linker Command"
//     -) Content: "-o output.o input.o"
//   - Linker version number:
//     -) Label: "Linker Version"
//     -) Content: "1.0.0"
//   - SDK version number:
//     -) Label: "SDK Version"
//     -) Content: "1.1.3"
type StringItem struct {
	Label   string
	Content string
}

type DepTrackr interface {
	QueryItem(item string) bool
	CopyItem(item string)
	AddItem(item string, stringItem []StringItem) error
	Save() error
}

// The depTrackrDotD is using the output of compilers like gcc,
// clang, etc. It uses the .d files generated by these compilers.
type depTrackrDotD struct {
	current      *depTrackr
	currentState State
	future       *depTrackr
	hasher       hash.Hash
}

func LoadDotdDepTrackr(buildDir string) DepTrackr {
	current := loadDepTrackr(buildDir, "deptrackr (.d files), v1.0.0")
	tracker := current.newDepTrackr()
	return &depTrackrDotD{
		current:      current,
		currentState: StateUpToDate, // Start with an up-to-date state
		future:       tracker,
		hasher:       sha1.New(),
	}
}

func (d *depTrackrDotD) Save() error {
	if d.currentState == StateUpToDate {
		// If the current state is up to date, we do not need to save anything
		return nil
	}
	return d.future.save()
}

func fileModCompare(fa []byte, fb []byte) bool {
	// Compare the file modification times
	if len(fa) != len(fb) {
		return false
	}
	for i := range fa {
		if fa[i] != fb[i] {
			return false
		}
	}
	return true
}

// QueryFile checks if the files are up to date, returning true if it is,
// or false if it is out of date or does not exist in the current state.
func (d *depTrackrDotD) QueryItem(item string) bool {
	d.hasher.Reset()
	d.hasher.Write([]byte(item))
	mainDigest := d.hasher.Sum(nil)

	state, err := d.current.QueryItem(mainDigest, true, func(itemChangeFlags uint16, itemChangeData []byte, itemIdFlags uint16, itemIdData []byte) State {
		if itemIdFlags&ItemFlagSourceFile == ItemFlagSourceFile || itemIdFlags&ItemFlagDependency == ItemFlagDependency {
			// Items that have been gone through a query have been updated with their current state which
			// was either up to date or out of date. This avoids asking the filesystem for the state of the file
			// if it is already known to be up to date or out of date.
			// This is mainly relevant for dependency files, which can be shared between multiple main items.
			if itemChangeFlags&ItemFlagUpToDate == ItemFlagUpToDate {
				return StateUpToDate
			}
			if itemChangeFlags&ItemFlagOutOfDate == ItemFlagOutOfDate {
				return StateOutOfDate
			}
			srcFileInfo, err := os.Stat(string(itemIdData))
			if err == nil {
				fileModTimeData, _ := srcFileInfo.ModTime().MarshalBinary()
				if fileModCompare(fileModTimeData, itemChangeData) {
					return StateUpToDate
				}
			}
			return StateOutOfDate
		} else {
			// This is not a source file or dependency file, so we ignore it
			return StateIgnore
		}
	})

	if err != nil {
		fmt.Println("Error querying item:", err)
	}

	return state == StateUpToDate
}

// In short form, a .d file (items are separated by '\'):
// <object-file>: \ <source-file> \ <header-file> \ ...

func (d *depTrackrDotD) CopyItem(item string) {
	d.hasher.Reset()
	d.hasher.Write([]byte(item))
	itemHash := d.hasher.Sum(nil)
	d.current.CopyItem(d.future, itemHash)
}

// item = depfileAbsFilepath
func (d *depTrackrDotD) AddItem(item string, stringItem []StringItem) error {
	contentBytes, err := os.ReadFile(item)
	if err != nil {
		return err
	}

	type part struct {
		from int
		to   int
	}

	// Parse the .d file content
	content := string(contentBytes)
	var parts []part
	current := part{from: 0, to: 0} // Start with an empty part
	startPos := 0
	for startPos < len(content) {
		endPos := strings.Index(content[startPos:], "\\")
		if endPos == -1 {
			endPos = len(content)
		} else {
			endPos += startPos
		}

		// If we encounter a backslash, we assume the next part starts
		// Figure out the 'to' index of the current part by stepping back
		// ignoring any spaces, tabs, or newlines before the backslash
		end := endPos - 1
		for end >= 0 && (content[end] == ' ' || content[end] == '\t' || content[end] == '\n' || content[end] == '\r' || content[end] == ':') {
			end-- // move back until we find a non-(space,tab,cr,ln,:) character
		}
		current.to = end + 1 // set the 'to' index of the last part
		parts = append(parts, current)

		// Now we need to find the beginning of the next part, but first
		// skip space, tab, and newline characters after a backslash
		begin := endPos + 1
		for begin < len(content) && (content[begin] == ' ' || content[begin] == '\t' || content[begin] == '\n' || content[begin] == '\r') {
			begin++ // move forward until we find a non-(space,tab,cr,ln) character
		}
		current = part{from: begin, to: begin} // Start a new part

		startPos = begin // Set the index to continue scanning
	}

	// part[0] is the object file, the rest are dependencies
	// Note: also add the .d file itself as a dependency

	// ----------------------------------------------------------------
	// We want the main item to be the .d file
	d.hasher.Write([]byte(item))
	mainHash := d.hasher.Sum(nil)

	// For the 'change', we want the file modification time and hash it
	modTimeBytes := make([]byte, 8)
	fileInfo, err := os.Stat(item)
	if err != nil {
		binary.LittleEndian.PutUint64(modTimeBytes, uint64(time.Now().Unix())) // If the file does not exist, use the current time
	} else {
		binary.LittleEndian.PutUint64(modTimeBytes, uint64(fileInfo.ModTime().Unix()))
	}

	// We are adding a new item, so the state is out of date
	d.currentState = StateOutOfDate

	itemToAdd := ItemToAdd{
		IdData:       []byte(item),
		IdDigest:     mainHash,
		IdFlags:      ItemFlagSourceFile,
		ChangeData:   modTimeBytes,
		ChangeDigest: nil, // mod-time is small enough, we do not need a hash
		ChangeFlags:  ChangeFlagModTime,
	}

	var depItems []ItemToAdd
	for _, p := range parts {
		// Make sure the digest of a dependency will be unique and
		// not identical when the same file is used as a main item
		pStr := content[p.from:p.to]
		d.hasher.Reset()
		d.hasher.Write([]byte{'d', 'e', 'p'})
		d.hasher.Write([]byte(pStr))
		depDigest := d.hasher.Sum(nil)

		// For the 'change', we want the file modification time and hash it
		fileInfo, err = os.Stat(string(content[p.from:p.to]))
		if err != nil {
			binary.LittleEndian.PutUint64(modTimeBytes, uint64(time.Now().Unix()))
		} else {
			binary.LittleEndian.PutUint64(modTimeBytes, uint64(fileInfo.ModTime().Unix()))
		}

		depItemToAdd := ItemToAdd{
			IdDigest:     depDigest,
			IdData:       []byte(content[p.from:p.to]),
			IdFlags:      ItemFlagDependency,
			ChangeDigest: nil, // mod-time is small enough, we do not need a hash
			ChangeData:   modTimeBytes,
			ChangeFlags:  ChangeFlagModTime,
		}
		depItems = append(depItems, depItemToAdd)
	}

	// Add the string items as dependencies
	for _, strItem := range stringItem {
		d.hasher.Reset()
		d.hasher.Write([]byte(strItem.Label))
		depDigest := d.hasher.Sum(nil)

		d.hasher.Reset()
		d.hasher.Write([]byte(strItem.Content))
		contentDigest := d.hasher.Sum(nil)

		depItemToAdd := ItemToAdd{
			IdDigest:     depDigest,
			IdData:       []byte(strItem.Label),
			IdFlags:      ItemFlagString,
			ChangeDigest: contentDigest,
			ChangeData:   []byte(strItem.Content),
			ChangeFlags:  ChangeFlagString,
		}

		depItems = append(depItems, depItemToAdd)
	}

	d.future.AddItem(itemToAdd, depItems)
	return nil
}
