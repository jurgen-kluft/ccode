package clay

// Open Questions:
//
// - Q: How do identify stale entries that should be pruned?
//   A: We use reference counting to identify stale entries.

// Design and Implementation Notes:
// - Fully custom database
// - Could be written in C, since can have mmap and other
//   performance optimizations.

// Dependency Tracking General Information:
//
// The purpose of dependency tracking is to not compile a source file if it
// and all of its dependencies have not changed, including the .o output file.
//
// In C/C++, a source file can include other source files and header files.
// This can create a tree of dependencies, the root of the tree is the main
// source file.
//
// Gcc and other compilers generate a .d file that contains the dependencies of
// a source file. The .d file is generated by the compiler and contains the
// dependencies of the source file.
//

// API:
// - Load
// - Save
// - Register a file and its dependencies
// - Unregister a file
// - Query a file and return the state (up-to-date, out-of-date).
//   Possibly returning []*Item that have contributed to the out-of-date state.

// item.db.clay
// Item (16 bytes)
//   - int32, index to Hash-Node, this is the ID of the item (filepath, label (e.g. 'MSVC C++ compiler cmd-line arguments))
//   - int32, index to Hash-Node, this identifies the 'change' (modification-time, file-size, file-content, command-line arguments, string, etc..)
//   - int32, ref-count, for identifying stale entries
//   - int32, padding

// A file represents a source file, header file or any other file that is
// a dependency of a source file. The file is identified by its hash, whic
// is a SHA1 hash of the file path.

// dep.db.clay
// Dep (16 bytes)
//   - int32, index to Item
//   - int32, index to Node (list of dependencies, e.g. '.d', '.o' file and '.h' files)
//            this list should be sorted by Item.ID
//   - int32, ref-count, for identifying stale entries
//   - int32, padding

// A dependency represents the dependency description of:
// - a file (.cpp, .c, .exe, .lib, .a, etc..)
// - a command line argument (e.g. MSVC C++ compiler cmd-line arguments)
// - a version of a something (e.g. Visual Studio, GCC, Arduino, etc..)

// node.db.clay
// Node (16 bytes)
//   - int32, index to Item
//   - int32, next Node
//   - int32, prev Node
//   - int32, ref-count, for identifying stale entries

// hash-node.db.clay
// Hash-Node (16 bytes)
//   - int32, index to Data (string, byte-array, or 0 if no Data (e.g. modification-time, file-size))
//   - int32, index to byte[20] (SHA1 of Data)
//   - int32, ref-count, for identifying stale entries
//   - int32, flags, for identifying the type of data (e.g. string, byte-array, etc..)

// Note: item.db.clay + dep.db.clay + node.db.clay + hash-node.db.clay
//       can all be in the same file?
//
// So then we have three files:
// - clay.db.clay (for the item, dep, node, hash-node)
// - hash.db.clay (for the hash of the data)
// - data.db.clay (for the hash of the data)

// We decouple hash-node and the actual hash, so that we can sort on the
// hash-node and not the hash. When sorting we can 'update' the Hash-Node
// index of the Item or Node.
//

// hash.db.clay
// Hash (32 bytes)
//   - ref-count is for identifying stale entries
//   - ref-count, padding, padding, hash ([byte[4], byte[4], byte[4], byte[20])

// data.db.clay
// Data
//   - useful to have for debugging
//   - has a length prefix of uint32
//   - ref-count is for identifying stale entries
//   - [ref-count][length][bytes[length]]{padding}
//   - aligned to 8 bytes
