package clay

import (
	"os"
	"path/filepath"
)

// SourceFile dependencies are mostly generated by the compiler
type SourceFile struct {
	SrcAbsPath string // This is the absolute file path
	SrcRelPath string // This is the relative file path
	IsCpp      bool   // Is this a C++ source file (true) or a C source file (false)
	ObjRelPath string // This is the output object file path
	DepRelPath string // Mostly at the same location as the object file
}

// Library represents a C/C++ library that can be linked with an executable
type Library struct {
	Name            string // Name of the library
	Config          string // Config to identify the library
	IsSystemLibrary bool   // Is this a system library (true) or a user-defined library (false)
	IsCppLibrary    bool   // Is this a C++ library (true) or a C library (false)
	BuildSubDir     string // Subdirectory for the library build (optional)
	OutputFilename  string // Relative filepath to the build output (.lib, .a)

	Defines     *ValueSet     // Compiler defines (macros) for the library
	IncludeDirs *IncludeMap   // Include paths for the library (system)
	SourceFiles []*SourceFile // C/C++ Source files for the library
}

func NewLibrary(name string, config string, buildSubDir string, outputFilename string) *Library {
	return &Library{
		Name:            name,
		Config:          config,
		IsSystemLibrary: false,
		IsCppLibrary:    false,
		BuildSubDir:     buildSubDir,
		OutputFilename:  outputFilename,
		Defines:         NewValueSet(),
		IncludeDirs:     NewIncludeMap(),
		SourceFiles:     make([]*SourceFile, 0),
	}
}

func NewCLibrary(name string, config string, buildSubDir string, outputFilename string) *Library {
	lib := NewLibrary(name, config, buildSubDir, outputFilename)
	lib.IsCppLibrary = false
	return lib
}

func NewCppLibrary(name string, config string, buildSubDir string, outputFilename string) *Library {
	lib := NewLibrary(name, config, buildSubDir, outputFilename)
	lib.IsCppLibrary = true
	return lib
}

func (lib *Library) AddSourceFile(srcPath string, srcRelPath string, isCpp bool) {
	srcFile := &SourceFile{
		SrcAbsPath: srcPath,
		SrcRelPath: srcRelPath,
		IsCpp:      isCpp,
		ObjRelPath: "",
		DepRelPath: "",
	}
	lib.SourceFiles = append(lib.SourceFiles, srcFile)
}

type AddSourceFileOptions int

const (
	OptionAddCppFiles            AddSourceFileOptions = 1
	OptionAddCFiles              AddSourceFileOptions = 2
	OptionAddRecursively         AddSourceFileOptions = 4
	OptionRecursivelyAddCppFiles AddSourceFileOptions = OptionAddCppFiles | OptionAddRecursively
	OptionRecursivelyAddCFiles   AddSourceFileOptions = OptionAddCFiles | OptionAddRecursively
)

func HasOption(options AddSourceFileOptions, option AddSourceFileOptions) bool {
	return (options & option) != 0
}

func (lib *Library) AddSourceFilesFrom(srcPath string, options AddSourceFileOptions) {
	// Find all source files in the given path and add them to SourceFiles
	// This function should handle the recursive search if 'recursive' is true
	filepath.Walk(srcPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			if HasOption(options, OptionAddRecursively) {
				return nil // Continue walking the tree
			}

			if path == srcPath {
				return nil
			}
			return filepath.SkipDir
		}

		relPath := path[len(srcPath):] // Get the relative path

		isCpp := HasOption(options, OptionAddCppFiles) && filepath.Ext(relPath) == ".cpp"
		isC := !isCpp && (HasOption(options, OptionAddCFiles) && filepath.Ext(relPath) == ".c")
		if isCpp || isC {
			lib.AddSourceFile(path, relPath, isCpp)
		}
		return nil
	})
}

func (lib *Library) PrepareOutput(buildDir string) {
	for _, src := range lib.SourceFiles {
		src.ObjRelPath = filepath.Join(buildDir, lib.BuildSubDir, src.SrcRelPath) + ".o"
		src.DepRelPath = filepath.Join(buildDir, lib.BuildSubDir, src.SrcRelPath) + ".d"
	}
}

// Executable represents a C/C++ executable that can be built using the Clay build system.
type Executable struct {
	Name           string        // Name of the executable
	OutputFilePath string        // FilePath to the executable
	ObjectFiles    []*SourceFile // Object files that this executable is linking with (optional)
	Libraries      []*Library    // Libraries that this executable is linking with
}

func NewExecutable(name string, outputPath string) *Executable {
	executableFilepath := name + ".elf"
	return &Executable{
		Name:           name,
		OutputFilePath: executableFilepath,
		ObjectFiles:    make([]*SourceFile, 0),
		Libraries:      make([]*Library, 0),
	}
}

func (exe *Executable) AddLibrary(lib *Library) {
	exe.Libraries = append(exe.Libraries, lib)
}

type Compiler struct {
	CompilerPath         string                                                                        // FilePath to the compiler
	Defines              *ValueSet                                                                     // Compiler defines (macros) for the compiler
	Switches             *ValueSet                                                                     // Compiler switches (flags) for the compiler
	WarningSwitches      *ValueSet                                                                     // Warning switches (flags) for the compiler
	ResponseFileFlags    string                                                                        // FilePath to the C compiler flags file (optional)
	ResponseFileDefines  string                                                                        // FilePath to the C compiler defines file (optional)
	ResponseFileIncludes string                                                                        // FilePath to the C compiler includes file (optional)
	IncludePaths         *IncludeMap                                                                   // Include paths for the compiler (system level)
	BuildArgs            func(cl *Compiler, lib *Library, src *SourceFile, outputPath string) []string // Function to build the compiler arguments
}

func NewCompiler(compilerPath string) *Compiler {
	return &Compiler{
		CompilerPath:         compilerPath,
		Defines:              NewValueSet(),
		Switches:             NewValueSet(),
		WarningSwitches:      NewValueSet(),
		ResponseFileFlags:    "",
		ResponseFileDefines:  "",
		ResponseFileIncludes: "",
		IncludePaths:         NewIncludeMap(),
		BuildArgs:            func(cl *Compiler, lib *Library, src *SourceFile, outputPath string) []string { return nil },
	}
}

type Archiver struct {
	ArchiverPath string                                                       // FilePath to the linker
	BuildArgs    func(ar *Archiver, lib *Library, outputPath string) []string // Function to build the compiler arguments
}

func NewArchiver(arPath string) *Archiver {
	return &Archiver{
		ArchiverPath: arPath,
		BuildArgs:    func(ar *Archiver, lib *Library, outputPath string) []string { return nil },
	}
}

type Linker struct {
	LinkerPath    string    // FilePath to the linker package
	Defines       *ValueSet // Compiler defines (macros) for the compiler
	Switches      *ValueSet // Linker switches (flags) for the linker
	LibraryPaths  *ValueSet // Library paths for the linker (system)
	OutputMapFile bool      //

	ResponseFileLdFlags   string // FilePath to the linker flags file (optional)
	ResponseFileLdScripts string // FilePath to the linker scripts file (optional)
	ResponseFileLdLibs    string // FilePath to the linker libraries file (optional)

	BuildArgs func(l *Linker, exe *Executable, outputPath string) []string // Function to build the linker arguments
}

func NewLinker(linkerPath string) *Linker {
	return &Linker{
		LinkerPath:            linkerPath,
		Defines:               NewValueSet(),
		Switches:              NewValueSet(),
		LibraryPaths:          NewValueSet(),
		OutputMapFile:         false,
		ResponseFileLdFlags:   "",
		ResponseFileLdScripts: "",
		ResponseFileLdLibs:    "",
		BuildArgs:             func(l *Linker, exe *Executable, outputPath string) []string { return nil },
	}
}

type ImageGenerator struct {
	PartitionsBinToolPath       string                                                                 // 'python'
	PartitionsBinToolScript     string                                                                 // FilePath to the image generator script (optional)
	PartitionsBinToolOutputFile string                                                                 // FilePath to the partitions binary file
	PartitionsBinToolArgs       func(img *ImageGenerator, exe *Executable, outputPath string) []string // Function to build the image generator arguments
	ImageBinToolArgs            func(img *ImageGenerator, exe *Executable, outputPath string) []string // Function to build the image generator arguments
	ImageBinTool                *EspTool
}

func NewImageGenerator(genPartitionsToolPath string, genPartitionsToolScript string, espToolSettings *EspTool) *ImageGenerator {
	return &ImageGenerator{
		PartitionsBinToolPath:       genPartitionsToolPath,
		PartitionsBinToolScript:     genPartitionsToolScript,
		PartitionsBinToolOutputFile: "",
		PartitionsBinToolArgs:       func(img *ImageGenerator, exe *Executable, outputPath string) []string { return nil },
		ImageBinTool:                espToolSettings,
		ImageBinToolArgs:            func(img *ImageGenerator, exe *Executable, outputPath string) []string { return nil },
	}
}

type EspTool struct {
	ToolPath         string // FilePath to the ESP tool
	Chip             string // Chip name (e.g., ESP32, ESP32S3)
	Port             string // Port name (e.g., /dev/ttyUSB0, COM3) (optional)
	Baud             string // Baud rate (e.g., 115200, 921600) (optional)
	FlashMode        string // Flash mode (e.g., DIO, QIO)
	FlashFrequency   string // Flash frequency (e.g., 40m, 80m)
	FlashSize        string // Flash size (e.g., 4MB, 8MB)
	ElfShareOffset   string // ELF share offset (e.g., 0xb0)
	PartitionCsvFile string // FilePath to the partitions file
}

func NewEspTool(espImageToolPath string) *EspTool {
	return &EspTool{
		ToolPath:         espImageToolPath,
		Chip:             "",
		FlashMode:        "",
		FlashFrequency:   "",
		FlashSize:        "",
		ElfShareOffset:   "",
		PartitionCsvFile: "",
	}
}

type ImageStats struct {
	RAMSize   int64 // RAM size of the ELF file
	FlashSize int64 // Flash size of the ELF file
}

type ImageStatsTool struct {
	ElfSizeToolPath string                                                                // FilePath to the ELF size tool
	ToolArgs        func(es *ImageStatsTool, exe *Executable, outputPath string) []string // Function to build the ELF size tool arguments
	ParseStats      func(s string, exe *Executable) (*ImageStats, error)                  // Function to print the ELF size stats
}

func NewImageStatsTool(elfSizeToolPath string) *ImageStatsTool {
	return &ImageStatsTool{
		ElfSizeToolPath: elfSizeToolPath,
		ToolArgs:        func(es *ImageStatsTool, exe *Executable, outputPath string) []string { return nil },
		ParseStats:      func(s string, exe *Executable) (*ImageStats, error) { return &ImageStats{}, nil },
	}
}

type BootLoaderCompiler struct {
	EspTool *EspTool //
	// BootLoaderElfPath = $(ESP_SDK)/tools/esp32-arduino-libs/esp32/bin/bootloader_dio_40m.elf
	Variables *KeyValueSet // e.g. BootApp0
	Args      func(*BootLoaderCompiler, *Executable, string) []string
	Execute   func(*BootLoaderCompiler, *Executable, string) error
}

func NewBootLoaderCompiler(espToolSettings *EspTool) *BootLoaderCompiler {
	return &BootLoaderCompiler{
		EspTool:   espToolSettings,
		Variables: NewKeyValueSet(),
		Args:      func(g *BootLoaderCompiler, exe *Executable, outputPath string) []string { return nil },
		Execute:   func(g *BootLoaderCompiler, exe *Executable, outputPath string) error { return nil },
	}
}

// Flash the device with the images:
//    "/Users/obnosis5/sdk/arduino/esp32/tools/esptool//esptool"
//    --chip
//    esp32
//    --port
//    "/dev/tty.wchusbserial510"
//    --baud
//    921600
//    --before
//    default_reset
//    --after
//    hard_reset
//    write_flash
//    -z
//    --flash_mode
//    keep
//    --flash_freq
//    keep
//    --flash_size
//    keep
//    0x1000
//    "../target/mkESP/WiFiScan_esp32/WiFiScan.bootloader.bin"
//    0x8000
//    "../target/mkESP/WiFiScan_esp32/WiFiScan.partitions.bin"
//    0xe000
//    "/Users/obnosis5/sdk/arduino/esp32/tools/partitions/boot_app0.bin"
//    0x10000
//    "../target/mkESP/WiFiScan_esp32/WiFiScan.bin"

type FlashTool struct {
	Tool      *EspTool                                                         // FilePath to the ESP tool
	Variables *KeyValueSet                                                     // e.g. BootApp0
	Args      func(ft *FlashTool, exe *Executable, outputPath string) []string // Function to build the flash tool arguments
	Flash     func(ft *FlashTool, exe *Executable, outputPath string) error    // Function to flash the image to the device
}

func NewFlashTool(espToolSettings *EspTool) *FlashTool {
	return &FlashTool{
		Tool:      espToolSettings,
		Variables: NewKeyValueSet(),
		Args:      func(ft *FlashTool, exe *Executable, outputPath string) []string { return nil },
		Flash:     func(ft *FlashTool, exe *Executable, outputPath string) error { return nil },
	}
}

type BuildEnvironment struct {
	Name    string // Name of the compiler package
	Version string // Version of the compiler package
	SdkRoot string // Path to the SDK root directory

	CCompiler          *Compiler
	CppCompiler        *Compiler
	Archiver           *Archiver
	Linker             *Linker
	ImageGenerator     *ImageGenerator
	ImageStatsTool     *ImageStatsTool
	BootLoaderCompiler *BootLoaderCompiler
	FlashTool          *FlashTool

	EspTool *EspTool

	PrebuildFunc      func(be *BuildEnvironment, outputPath string) error                                 // Function that does prebuild for the compiler package
	BuildFunc         func(be *BuildEnvironment, exe *Executable, outputPath string) error                // Function that does all, compile, archive, link, and generate image
	BuildLibFunc      func(be *BuildEnvironment, lib *Library, outputPath string) error                   // Function to build a library
	CompileFunc       func(be *BuildEnvironment, lib *Library, src *SourceFile, outputPath string) error  // Function to compile a source file
	ArchiveFunc       func(be *BuildEnvironment, lib *Library, outputPath string) error                   // Function to create an archive (for libraries)
	LinkFunc          func(be *BuildEnvironment, exe *Executable, outputPath string) error                // Function to link libraries/object-files into an executable
	GenerateImageFunc func(be *BuildEnvironment, exe *Executable, outputPath string) error                // Function to generate an image from the executable
	GenerateStatsFunc func(be *BuildEnvironment, exe *Executable, outputPath string) (*ImageStats, error) // Function to get the ELF size stats
	FlashFunc         func(be *BuildEnvironment, exe *Executable, outputPath string) error                // Function to flash the image to the device
}

func NewBuildEnvironment(name string, version string, sdkRoot string) *BuildEnvironment {
	return &BuildEnvironment{
		Name:              name,
		Version:           version,
		SdkRoot:           sdkRoot,
		CCompiler:         nil,
		CppCompiler:       nil,
		Archiver:          nil,
		Linker:            nil,
		ImageGenerator:    nil,
		ImageStatsTool:    nil,
		PrebuildFunc:      func(be *BuildEnvironment, outputPath string) error { return nil },
		BuildFunc:         func(be *BuildEnvironment, exe *Executable, outputPath string) error { return nil },
		BuildLibFunc:      func(be *BuildEnvironment, lib *Library, outputPath string) error { return nil },
		CompileFunc:       func(be *BuildEnvironment, lib *Library, src *SourceFile, outputPath string) error { return nil },
		ArchiveFunc:       func(be *BuildEnvironment, lib *Library, outputPath string) error { return nil },
		LinkFunc:          func(be *BuildEnvironment, exe *Executable, outputPath string) error { return nil },
		GenerateImageFunc: func(be *BuildEnvironment, exe *Executable, outputPath string) error { return nil },
		GenerateStatsFunc: func(be *BuildEnvironment, exe *Executable, outputPath string) (*ImageStats, error) {
			return &ImageStats{}, nil
		},
		FlashFunc: func(be *BuildEnvironment, exe *Executable, outputPath string) error { return nil },
	}
}
