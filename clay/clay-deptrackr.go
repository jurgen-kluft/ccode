package clay

import (
	"crypto/sha1"
	"fmt"
	"hash"
	"os"

	dep "github.com/jurgen-kluft/ccode/clay/deptrackr"
)

// The DepTrackr in clay is using the output of compilers like gcc,
// clang, etc. It uses the .d files generated by these compilers.

type DepTrackr struct {
	Current      *dep.DepTrackr
	CurrentState dep.State
	New          *dep.DepTrackr
	Hasher       hash.Hash
}

func NewDepTrackr(buildDir string) *DepTrackr {
	return &DepTrackr{
		Current:      dep.NewDepTrackr(buildDir),
		CurrentState: dep.StateUpToDate, // Start with an up-to-date state
		New:          dep.NewDepTrackr(buildDir),
		Hasher:       sha1.New(),
	}
}

func (d *DepTrackr) Save() error {
	if d.CurrentState == dep.StateUpToDate {
		// If the current state is up to date, we do not need to save anything
		return nil
	}
	return d.New.Save()
}

func (d *DepTrackr) Load() error {
	return d.Current.Load()
}

func fileModCompare(fa []byte, fb []byte) bool {
	// Compare the file modification times
	if len(fa) != len(fb) {
		return false
	}
	for i := range fa {
		if fa[i] != fb[i] {
			return false
		}
	}
	return true
}

// QueryFile checks if the source file is up to date, returning true if it is,
// or false if it is out of date or does not exist in the current state.
func (d *DepTrackr) QueryFile(srcfileAbsFilepath string) bool {
	d.Hasher.Reset()
	d.Hasher.Write([]byte(srcfileAbsFilepath))
	mainDigest := d.Hasher.Sum(nil)

	state, err := d.Current.QueryItem(mainDigest, true, func(itemChangeFlags uint16, itemChangeData []byte, itemIdFlags uint16, itemIdData []byte) dep.State {
		if itemIdFlags&dep.ItemFlagSourceFile == dep.ItemFlagSourceFile || itemIdFlags&dep.ItemFlagDependency == dep.ItemFlagDependency {
			srcFileInfo, err := os.Stat(string(itemIdData))
			if err == nil {
				fileModTimeData, _ := srcFileInfo.ModTime().MarshalBinary()
				if fileModCompare(fileModTimeData, itemChangeData) {
					return dep.StateUpToDate
				}
			}
			return dep.StateOutOfDate
		} else {
			// This is not a source file or dependency file, so we ignore it
			return dep.StateIgnore
		}
	})

	if err != nil {
		fmt.Println("Error querying item:", err)
	}

	if state == dep.StateUpToDate {
		return true
	} else if state == dep.StateOutOfDate {
		d.CurrentState = dep.StateOutOfDate
	}

	return false
}

// In short form, a .d file (items are separated by '\'):
// <object-file>: \ <source-file> \ <header-file> \ ...

func (d *DepTrackr) AddFile(srcfileAbsFilepath string, depfileAbsFilepath string) error {
	content, err := os.ReadFile(depfileAbsFilepath)
	if err != nil {
		return err
	}

	type part struct {
		from int
		to   int
	}

	// Parse the .d file content
	parts := []part{}
	current := part{from: 0, to: 0} // Start with an empty part
	for i, c := range content {
		if c == '\\' {
			// If we encounter a backslash, we assume the next part starts
			// Figure out the 'to' index of the current part by stepping back
			// ignoring any spaces, tabs, or newlines before the backslash
			end := i - 1
			for end >= 0 && (content[end] == ' ' || content[end] == '\t' || content[end] == '\n' || content[end] == '\r' || content[end] == ':') {
				end-- // move back until we find a non-(space,tab,cr,ln,:) character
			}
			current.to = end + 1 // set the 'to' index of the last part
			parts = append(parts, current)

			// Now we need to find the beginning of the next part, but first
			// skip space, tab, and newline characters after a backslash
			begin := i + 1
			for begin < len(content) && (content[begin] == ' ' || content[begin] == '\t' || content[begin] == '\n' || content[begin] == '\r') {
				begin++ // move forward until we find a non-(space,tab,cr,ln) character
			}
			current = part{from: begin, to: begin} // Start a new part

			i = begin // Set the index to continue scanning
		}
	}
	current.to = len(content)      // Set the 'to' index of the last part
	parts = append(parts, current) // Add the last part

	// part[0] is the object file, the rest are dependencies
	// Note: also add the .d file itself as a dependency

	// ----------------------------------------------------------------
	// We want the main item to be the source file
	d.Hasher.Write([]byte(srcfileAbsFilepath))
	mainHash := d.Hasher.Sum(nil)

	// For the 'change', we want the file modification time and hash it
	fileInfo, err := os.Stat(srcfileAbsFilepath)
	if err != nil {
		return err
	}

	// Use the file modification time as part of the item data
	modTimeBytes, err := fileInfo.ModTime().MarshalBinary()

	item := dep.ItemToAdd{
		IdData:       []byte(srcfileAbsFilepath),
		IdDigest:     mainHash,
		IdFlags:      dep.ItemFlagSourceFile,
		ChangeData:   modTimeBytes,
		ChangeDigest: nil, // mod-time is small enough, we do not need a hash
		ChangeFlags:  dep.ChangeFlagModTime,
	}

	// ----------------------------------------------------------------
	// The .d file itself is also a dependency
	d.Hasher.Reset()
	d.Hasher.Write([]byte(depfileAbsFilepath))
	mainHash = d.Hasher.Sum(nil)

	// For the 'change', we want the file modification time and hash it
	fileInfo, err = os.Stat(depfileAbsFilepath)
	if err != nil {
		return err
	}

	// Use the file modification time as part of the item data
	modTimeBytes, err = fileInfo.ModTime().MarshalBinary()

	item = dep.ItemToAdd{
		IdData:       []byte(depfileAbsFilepath),
		IdDigest:     mainHash,
		IdFlags:      dep.ItemFlagDependency,
		ChangeData:   modTimeBytes,
		ChangeDigest: nil, // mod-time is small enough, we do not need a hash
		ChangeFlags:  dep.ChangeFlagModTime,
	}
	depItems := []dep.ItemToAdd{item}

	for _, p := range parts {
		// Make sure the digest of a dependency will be unique and
		// not collide when the same file is used as a main item
		d.Hasher.Reset()
		d.Hasher.Write([]byte{'d', 'e', 'p'})
		d.Hasher.Write(content[p.from:p.to])
		depDigest := d.Hasher.Sum(nil)

		// For the 'change', we want the file modification time and hash it
		fileInfo, err = os.Stat(string(content[p.from:p.to]))
		if err != nil {
			return err
		}

		// Use the file modification time as part of the item data
		modTimeBytes, err = fileInfo.ModTime().MarshalBinary()

		depItem := dep.ItemToAdd{
			IdDigest:     depDigest,
			IdData:       content[p.from:p.to],
			IdFlags:      dep.ItemFlagDependency,
			ChangeDigest: nil, // mod-time is small enough, we do not need a hash
			ChangeData:   modTimeBytes,
			ChangeFlags:  dep.ChangeFlagModTime,
		}
		depItems = append(depItems, depItem)
	}

	d.New.AddItem(item, depItems)

	return nil
}

type StringDependency struct {
	Main    string // e.g. 'Commandline arguments'
	Content string // e.g. '-I/usr/include -L/usr/lib'
}

// Examples:
//   - A library and the source files that where used to build it, as well as the
//     commandline arguments that were used.
//   - An executable and the library/archive files that where used to link it and the
//     commandline arguments that were used.
//   - A bootloader binary and the files that were used to build it, as well as the
//     commandline arguments that were used.
func (d *DepTrackr) AddFileAndDependencies(fileAbsFilepath string, listOfFileDependencies []string, listOfStringDependencies []StringDependency) error {

	// Add a library file and its dependencies to the dependency tracker

	// ----------------------------------------------------------------
	// We want the main item to be the source file
	d.Hasher.Write([]byte(fileAbsFilepath))
	mainHash := d.Hasher.Sum(nil)

	// For the 'change', we want the file modification time and hash it
	fileInfo, err := os.Stat(fileAbsFilepath)
	if err != nil {
		return err
	}

	// Use the file modification time as part of the item data
	modTimeBytes, err := fileInfo.ModTime().MarshalBinary()

	item := dep.ItemToAdd{
		IdData:       []byte(fileAbsFilepath),
		IdDigest:     mainHash,
		IdFlags:      dep.ItemFlagSourceFile,
		ChangeData:   modTimeBytes,
		ChangeDigest: nil, // mod-time is small enough, we do not need a hash
		ChangeFlags:  dep.ChangeFlagModTime,
	}

	// ----------------------------------------------------------------
	// The file itself is also a dependency
	d.Hasher.Reset()
	d.Hasher.Write([]byte(fileAbsFilepath))
	mainHash = d.Hasher.Sum(nil)

	// For the 'change', we want the file modification time and hash it
	fileInfo, err = os.Stat(fileAbsFilepath)
	if err != nil {
		return err
	}

	// Use the file modification time as part of the item data
	modTimeBytes, err = fileInfo.ModTime().MarshalBinary()

	item = dep.ItemToAdd{
		IdData:       []byte(fileAbsFilepath),
		IdDigest:     mainHash,
		IdFlags:      dep.ItemFlagSourceFile,
		ChangeData:   modTimeBytes,
		ChangeDigest: nil, // mod-time is small enough, we do not need a hash
		ChangeFlags:  dep.ChangeFlagModTime,
	}
	depItems := []dep.ItemToAdd{item}

	for _, p := range listOfFileDependencies {
		// Make sure the digest of a dependency will be unique and
		// not collide when the same file is used as a main item
		d.Hasher.Reset()
		d.Hasher.Write([]byte{'d', 'e', 'p'})
		d.Hasher.Write([]byte(p))
		depDigest := d.Hasher.Sum(nil)

		// For the 'change', we want the file modification time and hash it
		fileInfo, err = os.Stat(p)
		if err != nil {
			return err
		}

		// Use the file modification time as part of the item data
		modTimeBytes, err = fileInfo.ModTime().MarshalBinary()

		depItem := dep.ItemToAdd{
			IdDigest:     depDigest,
			IdData:       []byte(p),
			IdFlags:      dep.ItemFlagDependency,
			ChangeDigest: nil, // mod-time is small enough, we do not need a hash
			ChangeData:   modTimeBytes,
			ChangeFlags:  dep.ChangeFlagModTime,
		}
		depItems = append(depItems, depItem)
	}

	for _, p := range listOfStringDependencies {
		// Make sure the digest of a dependency will be unique and
		// not collide when the same file is used as a main item
		d.Hasher.Reset()
		d.Hasher.Write([]byte{'d', 'e', 'p'})
		d.Hasher.Write([]byte(p.Main))
		depDigest := d.Hasher.Sum(nil)

		d.Hasher.Reset()
		d.Hasher.Write([]byte(p.Content))
		contentDigest := d.Hasher.Sum(nil)

		depItem := dep.ItemToAdd{
			IdDigest:     depDigest,
			IdData:       []byte(p.Main),
			IdFlags:      dep.ItemFlagString,
			ChangeDigest: contentDigest,
			ChangeData:   []byte(p.Content),
			ChangeFlags:  dep.ChangeFlagString,
		}
		depItems = append(depItems, depItem)
	}

	d.New.AddItem(item, depItems)

	return nil

}
