package clay

import (
	"os"
	"path/filepath"
)

// TODO:
// - MINOR: Archiver
// - MINOR: Linker
// - MINOR: ESP32 S3
// - MAJOR: To reduce compile/link time we need Dependency Tracking (Database)
//   - source file -> object file
//     + args (excluding '<src> + -o <obj>')
//     + response files, they should be a dependency
//     + header files
//     + tool(s) used

// Project represents a C/C++ project that can be built using the Clay build system.
type Project struct {
	Name       string
	Version    string
	Libraries  []*Library  // Libraries that this project depends on
	Executable *Executable // Executable that this project builds (if any)
}

func NewProject(name string, version string) *Project {
	return &Project{
		Name:       name,
		Version:    version,
		Libraries:  make([]*Library, 0),
		Executable: nil,
	}
}

// SourceFile dependencies are mostly generated by the compiler
type SourceFile struct {
	SrcAbsPath string // This is the source file path
	IsCpp      bool   // Is this a C++ source file (true) or a C source file (false)
	ObjRelPath string // This is the output object file path
	DepRelPath string // Mostly at the same location as the object file
}

// Library represents a C/C++ library that can be linked with an executable or another library.
type Library struct {
	Name              string // Name of the C++ library
	Version           string // Version of the C++ library
	IsSystemLibrary   bool   // Is this a system library (true) or a user-defined library (false)
	IsCppLibrary      bool   // Is this a C++ library (true) or a C library (false)
	OutputRelFilePath string // Relative filepath to the build output (lib, ar, a, obj, o)

	Defines     *ValueMap     // Compiler defines (macros) for the C++ library
	IncludeDirs *IncludeMap   // Include paths for the C++ library (system)
	SourceFiles []*SourceFile // Source files for the C++ library
	Libraries   []*Library    // Libraries that this library depends on
}

func NewLibrary(name string, version string, outputRelFilePath string) *Library {
	return &Library{
		Name:              name,
		Version:           version,
		IsSystemLibrary:   false,
		IsCppLibrary:      false,
		OutputRelFilePath: outputRelFilePath,
		Defines:           NewValueMap(),
		IncludeDirs:       NewIncludeMap(),
		SourceFiles:       make([]*SourceFile, 0),
		Libraries:         make([]*Library, 0),
	}
}

func (lib *Library) AddSourceFilesFrom(srcPath string, buildPath string, recursive bool, cpp bool) {
	// Find all source files in the given path and add them to SourceFiles
	// This function should handle the recursive search if 'recursive' is true
	filepath.Walk(srcPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil // Skip directories
		}

		relPath := path[len(srcPath):] // Get the relative path

		if (cpp && filepath.Ext(relPath) == ".cpp") || (!cpp && filepath.Ext(relPath) == ".c") {
			srcFile := &SourceFile{
				SrcAbsPath: path,
				IsCpp:      cpp,
				ObjRelPath: "",
				DepRelPath: "",
			}
			lib.SourceFiles = append(lib.SourceFiles, srcFile)
		}
		return nil
	})
}

// Executable represents a C/C++ executable that can be built using the Clay build system.
type Executable struct {
	Name        string        // Name of the executable
	Version     string        // Version of the executable
	OutputPath  string        // FilePath to the executable
	ObjectFiles []*SourceFile // Object files that this executable is linking with
	Libraries   []*Library    // Libraries that this executable is linking with
}

func NewExecutable(name string, version string, outputPath string) *Executable {
	return &Executable{
		Name:        name,
		Version:     version,
		OutputPath:  outputPath,
		ObjectFiles: make([]*SourceFile, 0),
		Libraries:   make([]*Library, 0),
	}
}

type Compiler struct {
	CompilerPath    string                                                          // FilePath to the compiler
	Defines         *ValueMap                                                       // Compiler defines (macros) for the compiler
	Switches        *ValueMap                                                       // Compiler switches (flags) for the compiler
	WarningSwitches *ValueMap                                                       // Warning switches (flags) for the compiler
	AtFlagsFile     string                                                          // FilePath to the C compiler flags file (optional)
	AtDefinesFile   string                                                          // FilePath to the C compiler defines file (optional)
	AtIncludesFile  string                                                          // FilePath to the C compiler includes file (optional)
	IncludePaths    *IncludeMap                                                     // Include paths for the compiler (system level)
	BuildArgs       func(cl *Compiler, src *SourceFile, outputPath string) []string // Function to build the compiler arguments
}

func NewCompiler() *Compiler {
	return &Compiler{
		CompilerPath:    "",
		Defines:         NewValueMap(),
		Switches:        NewValueMap(),
		WarningSwitches: NewValueMap(),
		AtFlagsFile:     "",
		AtDefinesFile:   "",
		AtIncludesFile:  "",
		IncludePaths:    NewIncludeMap(),
		BuildArgs:       func(cl *Compiler, src *SourceFile, outputPath string) []string { return nil },
	}
}

type BuildEnvironment struct {
	Name           string    // Name of the compiler package
	Version        string    // Version of the compiler package
	ArchiverPath   string    // FilePath to the archiver package (for libraries)
	LinkerPath     string    // FilePath to the linker package
	LinkerDefines  *ValueMap // Compiler defines (macros) for the compiler
	LinkerSwitches *ValueMap // Linker switches (flags) for the linker
	CCompiler      *Compiler
	CppCompiler    *Compiler

	LinkerLibraryPaths  []string // Library paths for the linker (system)
	LinkerOutputMapFile *string  // Path to the linker output map file (optional)

	PreBuild   func() error                                       // Function to run before building
	Setup      func() error                                       // Function that does initial setup for the compiler package
	Compile    func(srcFile *SourceFile, outputPath string) error // Function to compile a source file
	PreArchive func() error                                       // Function to run before archiving
	Archive    func(lib *Library, outputPath string) error        // Function to create an archive (for libraries)
	PreLink    func() error                                       // Function to run before linking
	Link       func(exe Executable) error                         // Function to link libraries/object-files into an executable
}

func NewBuildEnvironment(name string, version string) *BuildEnvironment {
	return &BuildEnvironment{
		Name:                name,
		Version:             version,
		ArchiverPath:        "",
		LinkerPath:          "",
		LinkerDefines:       NewValueMap(),
		LinkerSwitches:      NewValueMap(),
		CCompiler:           nil,
		CppCompiler:         nil,
		LinkerLibraryPaths:  make([]string, 0),
		LinkerOutputMapFile: nil,
		PreBuild:            func() error { return nil },
		Setup:               func() error { return nil },
		Compile:             func(srcFile *SourceFile, outputPath string) error { return nil },
		PreArchive:          func() error { return nil },
		Archive:             func(lib *Library, outputPath string) error { return nil },
		PreLink:             func() error { return nil },
		Link:                func(exe Executable) error { return nil },
	}
}
