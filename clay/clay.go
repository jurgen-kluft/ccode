package clay

import (
	"os"
	"path/filepath"
)

// SourceFile dependencies are mostly generated by the compiler
type SourceFile struct {
	SrcAbsPath string // This is the source file path
	IsCpp      bool   // Is this a C++ source file (true) or a C source file (false)
	ObjRelPath string // This is the output object file path
	DepRelPath string // Mostly at the same location as the object file
}

// Library represents a C/C++ library that can be linked with an executable
type Library struct {
	Name            string // Name of the library
	Version         string // Version of the library
	IsSystemLibrary bool   // Is this a system library (true) or a user-defined library (false)
	IsCppLibrary    bool   // Is this a C++ library (true) or a C library (false)
	BuildSubDir     string // Subdirectory for the library build (optional)
	OutputFilename  string // Relative filepath to the build output (.lib, .a)

	Defines     *ValueMap     // Compiler defines (macros) for the library
	IncludeDirs *IncludeMap   // Include paths for the library (system)
	SourceFiles []*SourceFile // C/C++ Source files for the library
	Libraries   []*Library    // Libraries that this library depends on
}

func NewLibrary(name string, version string, buildSubDir string, outputFilename string) *Library {
	return &Library{
		Name:            name,
		Version:         version,
		IsSystemLibrary: false,
		IsCppLibrary:    false,
		BuildSubDir:     buildSubDir,
		OutputFilename:  outputFilename,
		Defines:         NewValueMap(),
		IncludeDirs:     NewIncludeMap(),
		SourceFiles:     make([]*SourceFile, 0),
		Libraries:       make([]*Library, 0),
	}
}

func NewCLibrary(name string, version string, buildSubDir string, outputFilename string) *Library {
	lib := NewLibrary(name, version, buildSubDir, outputFilename)
	lib.IsCppLibrary = false
	return lib
}

func NewCppLibrary(name string, version string, buildSubDir string, outputFilename string) *Library {
	lib := NewLibrary(name, version, buildSubDir, outputFilename)
	lib.IsCppLibrary = true
	return lib
}

type AddSourceFileOptions int

const (
	OptionAddCppFiles            AddSourceFileOptions = 1
	OptionAddCFiles              AddSourceFileOptions = 2
	OptionAddRecursively         AddSourceFileOptions = 4
	OptionRecursivelyAddCppFiles AddSourceFileOptions = OptionAddCppFiles | OptionAddRecursively
	OptionRecursivelyAddCFiles   AddSourceFileOptions = OptionAddCFiles | OptionAddRecursively
)

func HasOption(options AddSourceFileOptions, option AddSourceFileOptions) bool {
	return (options & option) != 0
}

func (lib *Library) AddSourceFilesFrom(srcPath string, options AddSourceFileOptions) {
	// Find all source files in the given path and add them to SourceFiles
	// This function should handle the recursive search if 'recursive' is true
	filepath.Walk(srcPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			if !HasOption(options, OptionAddRecursively) {
				return filepath.SkipDir // Skip directories if not recursive
			}
			return nil // Continue walking the tree
		}

		relPath := path[len(srcPath):] // Get the relative path

		if (HasOption(options, OptionAddCppFiles) && filepath.Ext(relPath) == ".cpp") || (HasOption(options, OptionAddCFiles) && filepath.Ext(relPath) == ".c") {
			srcFile := &SourceFile{
				SrcAbsPath: path,
				IsCpp:      HasOption(options, OptionAddCppFiles),
				ObjRelPath: "",
				DepRelPath: "",
			}
			lib.SourceFiles = append(lib.SourceFiles, srcFile)
		}
		return nil
	})
}

// Executable represents a C/C++ executable that can be built using the Clay build system.
type Executable struct {
	Name           string        // Name of the executable
	Version        string        // Version of the executable
	OutputFilePath string        // FilePath to the executable
	ObjectFiles    []*SourceFile // Object files that this executable is linking with (optional)
	Libraries      []*Library    // Libraries that this executable is linking with
}

func NewExecutable(name string, version string, outputPath string) *Executable {
	return &Executable{
		Name:           name,
		Version:        version,
		OutputFilePath: outputPath,
		ObjectFiles:    make([]*SourceFile, 0),
		Libraries:      make([]*Library, 0),
	}
}

type Compiler struct {
	CompilerPath    string                                                          // FilePath to the compiler
	Defines         *ValueMap                                                       // Compiler defines (macros) for the compiler
	Switches        *ValueMap                                                       // Compiler switches (flags) for the compiler
	WarningSwitches *ValueMap                                                       // Warning switches (flags) for the compiler
	AtFlagsFile     string                                                          // FilePath to the C compiler flags file (optional)
	AtDefinesFile   string                                                          // FilePath to the C compiler defines file (optional)
	AtIncludesFile  string                                                          // FilePath to the C compiler includes file (optional)
	IncludePaths    *IncludeMap                                                     // Include paths for the compiler (system level)
	BuildArgs       func(cl *Compiler, src *SourceFile, outputPath string) []string // Function to build the compiler arguments
}

func NewCompiler(compilerPath string) *Compiler {
	return &Compiler{
		CompilerPath:    compilerPath,
		Defines:         NewValueMap(),
		Switches:        NewValueMap(),
		WarningSwitches: NewValueMap(),
		AtFlagsFile:     "",
		AtDefinesFile:   "",
		AtIncludesFile:  "",
		IncludePaths:    NewIncludeMap(),
		BuildArgs:       func(cl *Compiler, src *SourceFile, outputPath string) []string { return nil },
	}
}

type Archiver struct {
	ArchiverPath string                                                       // FilePath to the linker
	BuildArgs    func(ar *Archiver, lib *Library, outputPath string) []string // Function to build the compiler arguments
}

func NewArchiver(arPath string) *Archiver {
	return &Archiver{
		ArchiverPath: arPath,
		BuildArgs:    func(ar *Archiver, lib *Library, outputPath string) []string { return nil },
	}
}

type Linker struct {
	LinkerPath    string    // FilePath to the linker package
	Defines       *ValueMap // Compiler defines (macros) for the compiler
	Switches      *ValueMap // Linker switches (flags) for the linker
	LibraryPaths  []string  // Library paths for the linker (system)
	OutputMapFile *string   // RelPath to the linker output map file (optional)

	AtLdFlagsFile   string // FilePath to the linker flags file (optional)
	AtLdScriptsFile string // FilePath to the linker scripts file (optional)
	AtLdLibsFile    string // FilePath to the linker libraries file (optional)

	BuildArgs func(l *Linker, exe Executable, outputPath string) []string // Function to build the linker arguments
}

func NewLinker(linkerPath string) *Linker {
	return &Linker{
		LinkerPath:    linkerPath,
		Defines:       NewValueMap(),
		Switches:      NewValueMap(),
		LibraryPaths:  make([]string, 0),
		OutputMapFile: nil,
		BuildArgs:     func(l *Linker, exe Executable, outputPath string) []string { return nil },
	}
}

type ImageGenerator struct {
	GenPath   string // FilePath to the image generator
	GenScript string // FilePath to the image generator script (optional)

	PartitionCsvFile        string // FilePath to the partitions file
	PartitionsBinOutputFile string // FilePath to the partitions binary file
	EspToolPath             string // FilePath to the ESP tool

	Chip           string // Chip name (e.g., ESP32, ESP32S3)
	FlashMode      string // Flash mode (e.g., DIO, QIO)
	FlashFrequency string // Flash frequency (e.g., 40m, 80m)
	FlashSize      string // Flash size (e.g., 4MB, 8MB)
	ElfShareOffset string // ELF share offset (e.g., 0xb0)

	GenArgs func(img *ImageGenerator, exe *Executable, outputPath string) []string // Function to build the image generator arguments
}

func NewImageGenerator(genPath string, genScript string) *ImageGenerator {
	return &ImageGenerator{
		GenPath:   genPath,
		GenScript: genScript,
		GenArgs:   func(img *ImageGenerator, exe *Executable, outputPath string) []string { return nil },
	}
}

type ImageStats struct {
	RAMSize   int64 // RAM size of the ELF file
	FlashSize int64 // Flash size of the ELF file
}

type ImageStatsTool struct {
	ElfSizeToolPath string                                                                // FilePath to the ELF size tool
	GenArgs         func(es *ImageStatsTool, exe *Executable, outputPath string) []string // Function to build the ELF size tool arguments
	GetStats        func(s string, exe *Executable) (*ImageStats, error)                  // Function to print the ELF size stats
}

type BuildEnvironment struct {
	Name    string // Name of the compiler package
	Version string // Version of the compiler package
	SdkRoot string // Path to the SDK root directory

	CCompiler      *Compiler
	CppCompiler    *Compiler
	Archiver       *Archiver
	Linker         *Linker
	ImageGenerator *ImageGenerator
	ImageStatsTool *ImageStatsTool

	SetupFunc         func(be *BuildEnvironment) error                                                   // Function that does initial setup for the compiler package
	PrebuildFunc      func(be *BuildEnvironment) error                                                   // Function that does prebuild for the compiler package
	BuildFunc         func(be *BuildEnvironment) error                                                   // Function that does all, compile, archive, link, and generate image
	BuildLibFunc      func(be *BuildEnvironment, lib *Library, outputPath string) error                  // Function that does all, compile, archive, link, and generate image
	CompileFunc       func(be *BuildEnvironment, src *SourceFile, outputPath string) error               // Function to compile a source file
	ArchiveFunc       func(be *BuildEnvironment, lib *Library, outputPath string) error                  // Function to create an archive (for libraries)
	LinkFunc          func(be *BuildEnvironment, exe Executable, outputPath string) error                // Function to link libraries/object-files into an executable
	GenerateImageFunc func(be *BuildEnvironment, exe Executable, outputPath string) error                // Function to generate an image from the executable
	GenerateStatsFunc func(be *BuildEnvironment, exe Executable, outputPath string) (*ImageStats, error) // Function to get the ELF size stats
}

func NewBuildEnvironment(name string, version string, sdkRoot string) *BuildEnvironment {
	return &BuildEnvironment{
		Name:              name,
		Version:           version,
		SdkRoot:           sdkRoot,
		CCompiler:         nil,
		CppCompiler:       nil,
		Archiver:          nil,
		Linker:            nil,
		ImageGenerator:    nil,
		ImageStatsTool:    nil,
		SetupFunc:         func(be *BuildEnvironment) error { return nil },
		PrebuildFunc:      func(be *BuildEnvironment) error { return nil },
		BuildFunc:         func(be *BuildEnvironment) error { return nil },
		BuildLibFunc:      func(be *BuildEnvironment, lib *Library, outputPath string) error { return nil },
		CompileFunc:       func(be *BuildEnvironment, src *SourceFile, outputPath string) error { return nil },
		ArchiveFunc:       func(be *BuildEnvironment, lib *Library, outputPath string) error { return nil },
		LinkFunc:          func(be *BuildEnvironment, exe Executable, outputPath string) error { return nil },
		GenerateImageFunc: func(be *BuildEnvironment, exe Executable, outputPath string) error { return nil },
		GenerateStatsFunc: func(be *BuildEnvironment, exe Executable, outputPath string) (*ImageStats, error) {
			return &ImageStats{}, nil
		},
	}
}
