# package dep

## Open Questions:

- Q: How do identify stale entries that should be pruned?
  A: We use reference counting to identify stale entries.

## Design and Implementation Notes:

- Fully custom database structure
- Written in pure Go
- No external dependencies

## Dependency Tracking General Information:

The purpose of dependency tracking is to not compile a source file if it
and all of its dependencies have not changed, including the .o output file.

In C/C++, a source file can include other source files and header files.
This can create a tree of dependencies, the root of the tree is the main
source file.

GCC and other compilers generate a .d file that contains the dependencies of
a source file. The .d file is generated by the compiler and contains the
dependencies of the source file.
We could do #include directive scanning manually, but this is not trivial,
maybe in a next version we could experiment with this.

A dependency represents the dependency description of:

- a file (.cpp, .c, .exe, .lib, .a, etc..)
- a command line argument (e.g. MSVC C++ compiler cmd-line arguments)
- a version of a something (e.g. Visual Studio, GCC, Arduino, etc..)

## User API

- Load(dirpath)
  Load all files from disk (use load point, when Ok, delete previous save point(s))
- Save(dirpath)
  Save all files to disk (use save point)
- Register a file and its dependencies
  Register(string file, string[] deps)
- This would either create or update the file in the database and return
    the state of the file.
- Unregister a file
  Unregister(string file), this would remove the file from the database.
- Query a file and return the state (up-to-date, out-of-date).
  As a debugging feature, return []*Item that have contributed to the
  out-of-date state.

Note: The hash of data for Item ID should be different from the hash of the
      the same data for Item ID that is attached to a Dep.
      We could do this by prefixing the data with 'src' for Item and 'dep' for
      Dep, before generating the digest.

## item db

Item (16 bytes) (shared)

- int32, index to Hash-Node, this is the ID of the item (filepath, label (e.g. 'MSVC C++ compiler cmd-line arguments))
- int32, index to Hash-Node, this identifies the 'change' (modification-time, file-size, file-content, command-line arguments, string, etc..)
- int32, index to Node, this is the head of the list of dependencies
- int32, ref-count, for identifying stale entries

A file represents a source file, header file or any other file that is
a dependency of a source file. The file is identified by its hash, whic
is a SHA1 hash of the file path.

## node db

Node (16 bytes) (unique)

- int32, index to (dep) Item
- int32, Next
- int32, Prev

## hash db

Hash (32 bytes) (unique)

- hash (byte[20])
- int32, index to Data
- int32, index to Item
- uint32, flags

## data db

Data

- only useful for debugging
- has a length prefix of uint32
- ref-count is for identifying stale entries
- `[ref-count][length][bytes[length]]{padding}`
- aligned to 8 bytes
