package axe

import (
	"fmt"
	"path/filepath"
)

type MakeGenerator struct {
	LastGenId  UUID
	Workspace  *Workspace
	VcxProjCpu string
}

func NewMakeGenerator(ws *Workspace) *MakeGenerator {
	g := &MakeGenerator{
		LastGenId: GenerateUUID(),
		Workspace: ws,
	}

	return g
}

func (g *MakeGenerator) Generate() {
	g.generateWorkspace()
}

func (g *MakeGenerator) generateWorkspace() {

	if g.Workspace.StartupProject != nil {
		g.Workspace.StartupProject.GenDataMake.Makefile = filepath.Join(g.Workspace.GenerateAbsPath, "Makefile")
	}

	makefile := NewLineWriter()
	makefile.WriteLine("# generated by ccode::axe")

	g.generateCommonVars(makefile)

	makefile.WriteLine(".PHONY: clean build run")

	for _, project := range g.Workspace.ProjectList.Values {
		g.generateProject(project)
		makefile.NewLine()
		makefile.WriteILine("+", project.Name)
	}

	//----- build: ----------

	makefile.WriteLine("build:")
	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", g.escapeString(project.Name))
	}
	makefile.NewLine()

	makefile.WriteLine("all: build")
	makefile.NewLine()

	makefile.WriteLine("build:")
	makefile.WriteILine("+", "@echo \"--- Build Finished ---\"")
	makefile.NewLine()

	//----- run: ----------

	makefile.WriteLine("run: build")
	makefile.WriteILine("+", "@echo \"==============================================================\"")
	if g.Workspace.StartupProject == nil {
		makefile.WriteILine("+", "@echo \"no startup_project specified\"")
	} else {
		makefile.WriteILine("+", "$(MAKE) -f \"", g.Workspace.StartupProject.GenDataMake.Makefile, "\" run $(MFLAGS)")
	}
	makefile.NewLine()

	//----- clean: ----------

	makefile.WriteLine("clean:")
	makefile.WriteILine("+", "@echo \"==============================================================\"")
	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", "$(MAKE) -f \"", project.GenDataMake.Makefile, "\" clean $(MFLAGS)")
	}
	makefile.WriteILine("+", "@echo \"===== clean finished ===== \"")
	makefile.NewLine()

	// ---- project targets ----

	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", g.escapeString(project.Name), ":")
		for _, dp := range project.Dependencies.Values {
			makefile.WriteILine("+", g.escapeString(dp.Name))
		}
		makefile.NewLine()

		if !project.HasOutputTarget {
			continue
		}

		mtBuild := ""
		if project.Settings.MultiThreadedBuild {
			mtBuild = " -j "
		}

		makefile.WriteILine("\t@echo \"==============================================================\"")
		makefile.WriteILine("\t@echo \"[build project] ", project.Name, "\"")
		makefile.WriteILine("\t$(MAKE)", mtBuild, " -f \"", project.GenDataMake.Makefile, "\" build $(MFLAGS)")
		makefile.NewLine()
	}

	makefile.WriteToFile(g.Workspace.StartupProject.GenDataMake.Makefile)
}

func (g *MakeGenerator) generateCommonVars(makefile *LineWriter) {
	makefile.WriteILine("#!! Unix Makefile")
	makefile.WriteILine("#!! Works wir FreeBSD make or Linux gmake")
	makefile.NewLine()
	makefile.WriteILine("config ?= ", g.Workspace.Configs.DefaultConfigName())
	makefile.NewLine()
	makefile.NewLine()

	if g.Workspace.MakeTarget.OSIsWindows() {
		makefile.WriteILine("cmd_mkdir := cmd.exe /c mkdir.bat")
		makefile.WriteILine("cmd_rmdir := rm -rf")
		makefile.WriteILine("cmd_rm    := rm -f")
		makefile.WriteILine("cmd_copy  := cp -f")
	} else {
		makefile.WriteILine("cmd_mkdir := mkdir -p")
		makefile.WriteILine("cmd_rmdir := rm -rf")
		makefile.WriteILine("cmd_rm    := rm -f")
		makefile.WriteILine("cmd_copy  := cp -f")
	}
	makefile.NewLine()
}

func (g *MakeGenerator) generateProject(project *Project) {
	// if (!proj.hasOutputTarget) return;
	if !project.HasOutputTarget {
		return
	}

	project.GenDataMake.Makefile = filepath.Join(g.Workspace.GenerateAbsPath, project.Name+".make")
	fmt.Printf("generating makefile for project %s\n", project.GenDataMake.Makefile)

	makefile := NewLineWriter()
	g.generateCommonVars(makefile)

	{
		project.PchSuffix = ".gch"
		cppStd := g.Workspace.Config.CppStd
		if g.Workspace.MakeTarget.CompilerIsClang() {
			project.PchSuffix = ".pch"
			makefile.WriteILine("cmd_cpp   := clang++ -std=", cppStd)
			makefile.WriteILine("cmd_c     := clang")
			makefile.WriteILine("cmd_link  := clang++")
		} else if g.Workspace.MakeTarget.CompilerIsGcc() {
			makefile.WriteILine("cmd_cpp   := g++ -std=", cppStd)
			makefile.WriteILine("cmd_c     := gcc")
			makefile.WriteILine("cmd_link  := g++")
		} else {
			panic("Unsupported compiler " + g.Workspace.MakeTarget.CompilerAsString())
		}
		makefile.WriteILine("cmd_ar    := ar rcs")
	}

	if g.Workspace.MakeTarget.OSIsMac() && bool(project.Settings.CppAsObjCpp) {
		makefile.WriteILine("pch_header_compiler_language = objective-c++-header")
		makefile.WriteILine("cpp_source_compiler_language = objective-c++")
		makefile.WriteILine("c_source_compiler_language   = objective-c")
	} else {
		makefile.WriteILine("pch_header_compiler_language = c++-header")
		makefile.WriteILine("cpp_source_compiler_language = c++")
		makefile.WriteILine("c_source_compiler_language   = c")
	}

	makefile.NewLine()
	makefile.WriteLine("pwd = $$(pdw)")
	makefile.NewLine()
	makefile.WriteLine(".PHONY: clean build run")

	makefile.NewLine()

	for _, config := range project.Configs.Values {
		makefile.WriteILine("+", config.Type.String(), "__build")
		makefile.WriteILine("+", config.Type.String(), "__clean")
		makefile.WriteILine("+", config.Type.String(), "__run")
	}
	makefile.NewLine()
	makefile.WriteILine("all: build")
	makefile.NewLine()

	for _, config := range project.Configs.Values {
		g.generateProjectConfig(makefile, project, config)
	}

	makefile.WriteLine("#-----------")
	makefile.WriteILine("BUILD_TMP_DIR      = $($(config)__BUILD_TMP_DIR)")
	makefile.WriteILine("PCH_HEADER_SRC     = $($(config)__PCH_HEADER_SRC)")
	makefile.WriteILine("PCH_HEADER_PCH     = $($(config)__PCH_HEADER_PCH)")
	makefile.WriteILine("PCH_HEADER_DEP     = $($(config)__PCH_HEADER_DEP)")
	makefile.WriteILine("PCH_CC_FLAGS       = $($(config)__PCH_CC_FLAGS)")
	makefile.NewLine()
	makefile.WriteILine("CPP_INCLUDE_DIRS   = $($(config)__CPP_INCLUDE_DIRS)")
	makefile.WriteILine("CPP_INCLUDE_FILES  = $($(config)__CPP_INCLUDE_FILES)")
	makefile.WriteILine("CPP_FLAGS          = $($(config)__CPP_FLAGS)")
	makefile.WriteILine("CPP_DEFINES        = $($(config)__CPP_DEFINES)")
	makefile.WriteILine("C_FLAGS            = $($(config)__C_FLAGS)")
	makefile.WriteILine("C_DEFINES          = $($(config)__C_DEFINES)")
	makefile.WriteILine("LINK_FLAGS         = $($(config)__LINK_FLAGS)")
	makefile.WriteILine("LINK_LIB           = $($(config)__LINK_LIBS)")
	makefile.WriteILine("LINK_FILES         = $($(config)__LINK_FILES)")
	makefile.WriteILine("CPP_OBJ_FILES      = $($(config)__CPP_OBJ_FILES)")
	makefile.NewLine()
	makefile.WriteILine("build: $(config)__build")
	makefile.WriteILine("clean: $(config)__clean")
	makefile.WriteILine("run:   $(config)__run")
	makefile.NewLine()

	makefile.WriteToFile(project.GenDataMake.Makefile)
}

func (g *MakeGenerator) escapeString(s string) string {
	escapedStr := ""
	for _, ch := range s {
		switch ch {
		case ':', ' ':
			escapedStr += "\\" + string(ch)
		default:
			escapedStr += string(ch)
		}
	}
	return escapedStr
}

func (g *MakeGenerator) quotePath(v string) string {
	o := "\""
	if !filepath.IsAbs(v) {
		o += "$(pwd)/"
	}

	for _, ch := range v {
		switch ch {
		case '"':
			o += "\\\""
		default:
			o += string(ch)
		}
	}
	o += "\""
	return o
}

//	String Generator_makefile::get_obj_file(Config& config, FileEntry& f) {
//		return String(config.genData_makefile.cpp_obj_dir, Path::basename(f.path(), true), "_obj");
//	}
func (g *MakeGenerator) getObjFile(config *Config, f *FileEntry) string {
	return filepath.Join(config.GenDataMakefile.CppObjDir, PathFilename(f.Path, true)+".o")
}

func (g *MakeGenerator) generateProjectConfig(makefile *LineWriter, project *Project, config *Config) {

	makefile.NewLine()
	makefile.NewLine()

	makefile.WriteLine("#===== ", config.Type.String(), " ======================\n")
	makefile.WriteLine("#!!!")
	makefile.WriteLine("#!!! Make cannot handle file paths containing space in a variable")
	makefile.WriteLine("#!!! therefore we unroll all file dependencies directly in this makefile")
	makefile.WriteLine("#!!!")

	config.GenDataMakefile.CppObjDir = filepath.Join(g.Workspace.GenerateAbsPath, "obj", config.Type.String())

	makefile.WriteLine(config.Type.String(), "__build: ", g.escapeString(config.OutputTarget.Path))
	makefile.NewLine()

	makefile.WriteLine(config.Type.String(), "__clean: ")
	makefile.WriteLine()
	makefile.WriteILine("+", "$(cmd_rmdir) \"", config.BuildTmpDir.Path, "\"")
	if len(config.OutputTarget.Path) > 0 {
		makefile.WriteILine("+", "$(cmd_rm) \"", config.OutputTarget.Path, "\"")
	}
	makefile.NewLine()

	pch_header_dep := ""
	pch_header_pch := ""
	pch_header_pch_dir := ""
	pch_basename := ""
	pch_cc_flags := NewLineWriter()

	//------- pre-compiled header

	if project.PchHeader != nil {
		pch_basename = PathFilename(project.PchHeader.Path, true)

		pch_header_pch = filepath.Join(config.BuildTmpDir.Path, "pch", pch_basename, project.PchSuffix)
		pch_header_dep = pch_header_pch + ".d"

		pch_header_pch_dir = PathDirname(pch_header_pch)

		pch_cc_flags.WriteILine("+", "-I", g.quotePath(pch_header_pch_dir))
		pch_cc_flags.WriteILine("+", "-include", g.quotePath(project.PchHeader.Path))

		// makefile optional include cpp_dep
		makefile.WriteLine("-include", g.escapeString(pch_header_dep))
		// --------
		makefile.WriteLine("#--- pch_header dependencies ------")
		makefile.WriteILine("+", g.escapeString(pch_header_pch), ":", g.escapeString(project.PchHeader.Path))
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[precompiled header] $< => $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(pch_header_pch_dir))
		makefile.WriteILine("+", "$(cmd_cpp) -x $(pch_header_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) \\")
		makefile.WriteILine("+", "-o \"$@\" -c", g.quotePath(project.PchHeader.Path), " \\")
		makefile.WriteILine("+", "-MMD -MQ \"$@\" -MF", g.quotePath(pch_header_dep), " \\")
		makefile.NewLine()
		makefile.NewLine()
	}

	// o.append("\n");
	// o.append("#-------------------\n");

	// String cpp_defines;
	// String cpp_flags;
	// String link_flags;
	// String link_libs;
	// String link_files;
	// String include_files;
	// String include_dirs;
	// String cpp_obj_files;

	// for (auto& q : config.cpp_defines._final) {
	// 	cpp_defines.append("\\\n\t-D", q.path());
	// }
	// for (auto& q : config.cpp_flags._final) {
	// 	cpp_flags.append("\\\n\t", q.path());
	// }
	// for (auto& q : config.link_flags._final) {
	// 	link_flags.append("\\\n\t", q.path());
	// }
	// for (auto& q : config.link_dirs._final) {
	// 	link_libs.append("\\\n\t-L", quotePath(q.path()));
	// }
	// for (auto& q : config.link_libs._final) {
	// 	link_libs.append("\\\n\t-l", q.path());
	// }
	// for (auto& q : config.link_files._final) {
	// 	link_files.append("\\\n\t", quotePath(q.path()));
	// }
	// for (auto& q : config.include_files._final) {
	// 	include_files.append("\\\n\t-include ", quotePath(q.path()));
	// }
	// for (auto& q : config.include_dirs._final) {
	// 	include_dirs.append("\\\n\t-I", quotePath(q.path()));
	// }

	// for (auto q : proj.fileEntries) {
	// 	if (q.excludedFromBuild) continue;
	// 	cpp_obj_files.append("\\\n\t", escapeString(get_obj_file(config, q)));
	// }

	makefile.WriteLine("#-----------------------")

	cpp_defines := NewLineWriter()
	cpp_flags := NewLineWriter()
	link_flags := NewLineWriter()
	link_libs := NewLineWriter()
	link_files := NewLineWriter()
	include_files := NewLineWriter()
	include_dirs := NewLineWriter()
	cpp_obj_files := NewLineWriter()

	for _, q := range config.CppDefines.FinalDict.Values {
		cpp_defines.WriteILine("+", "-D", q)
	}

	for _, q := range config.CppFlags.FinalDict.Values {
		cpp_flags.WriteILine("+", q)
	}

	for _, q := range config.LinkFlags.FinalDict.Values {
		link_flags.WriteILine("+", q)
	}

	for _, q := range config.LinkDirs.FinalDict.Values {
		link_libs.WriteILine("+", "-L", g.quotePath(q))
	}

	for _, q := range config.LinkLibs.FinalDict.Values {
		link_libs.WriteILine("+", "-l", q)
	}

	for _, q := range config.LinkFiles.FinalDict.Values {
		link_files.WriteILine("+", g.quotePath(q))
	}

	for _, q := range config.IncludeFiles.FinalDict.Values {
		include_files.WriteILine("+", "-include", g.quotePath(q))
	}

	for _, q := range config.IncludeDirs.FinalDict.Values {
		include_dirs.WriteILine("+", "-I", g.quotePath(q))
	}

	for _, q := range project.FileEntries.Values {
		if q.ExcludedFromBuild {
			continue
		}
		cpp_obj_files.WriteILine("+", g.escapeString(g.getObjFile(config, q)))
	}

	makefile.WriteILine(config.Type.String(), "__BUILD_TMP_DIR  = ", g.escapeString(config.BuildTmpDir.Path))
	if project.PchHeader != nil {
		makefile.WriteILine(config.Type.String(), "__PCH_HEADER        = ", g.quotePath(project.PchHeader.Path))
		makefile.WriteILine(config.Type.String(), "__PCH_HEADER_PCH    = ", g.quotePath(pch_header_pch))
		makefile.WriteILine(config.Type.String(), "__PCH_HEADER_DEP    = ", g.quotePath(pch_header_dep))
	}

	makefile.WriteILine(config.Type.String(), "__PCH_CC_FLAGS      = ")
	makefile.Append(pch_cc_flags)

	makefile.WriteILine(config.Type.String(), "__CPP_INCLUDE_DIRS  = ")
	makefile.Append(include_dirs)

	makefile.WriteILine(config.Type.String(), "__CPP_INCLUDE_FILES = ")
	makefile.Append(include_files)

	makefile.WriteILine(config.Type.String(), "__CPP_FLAGS         = ")
	makefile.Append(cpp_flags)

	makefile.WriteILine(config.Type.String(), "__CPP_DEFINES       = ")
	makefile.Append(cpp_defines)

	makefile.WriteILine(config.Type.String(), "__LINK_FLAGS        = ")
	makefile.Append(link_flags)

	makefile.WriteILine(config.Type.String(), "__LINK_LIBS         = ")
	makefile.Append(link_libs)

	makefile.WriteILine(config.Type.String(), "__LINK_FILES        = ")
	makefile.Append(link_files)

	makefile.WriteILine(config.Type.String(), "__CPP_OBJ_FILES     = ")
	makefile.Append(cpp_obj_files)

	makefile.NewLine()
	makefile.WriteLine("#--- ", config.Type.String(), " cpp_obj dependencies ------")

	for _, f := range project.FileEntries.Values {
		if f.ExcludedFromBuild {
			continue
		}

		cpp_obj := g.getObjFile(config, f)
		cpp_dep := cpp_obj + ".d"
		cpp_src := f.Path

		if f.Is_C() {
			makefile.WriteLine("-include", g.escapeString(cpp_dep))
			makefile.WriteILine("+", g.escapeString(cpp_obj), ":", g.escapeString(cpp_src))
			makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
			makefile.WriteILine("+", "@echo \"[compile c] => $@\"")
			makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(PathDirname(cpp_obj)))
			makefile.WriteILine("+", "$(cmd_c) -x $(c_source_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) $(CPP_INCLUDE_FILES) \\")
			makefile.WriteILine("+", "-o \"$@\" -c", g.quotePath(cpp_src), " \\")
			makefile.WriteILine("+", "-MMD -MQ \"$@\" -MF", g.quotePath(cpp_dep), " \\")
			makefile.NewLine()
		} else if f.Is_CPP() {
			if project.PchHeader != nil {
				makefile.WriteILine("+", g.escapeString(cpp_obj), ":", g.escapeString(pch_header_pch))
			}

			makefile.WriteLine("-include", g.escapeString(cpp_dep))
			makefile.WriteILine("+", g.escapeString(cpp_obj), ":", g.escapeString(cpp_src))
			makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
			makefile.WriteILine("+", "@echo \"[compile cpp] => $@\"")
			makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(PathDirname(cpp_obj)))
			makefile.WriteILine("+", "$(cmd_cpp) -x $(cpp_source_compiler_language) $(PCH_CC_FLAGS) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) $(CPP_INCLUDE_FILES) \\")
			makefile.WriteILine("+", "-o \"$@\" -c", g.quotePath(cpp_src), " \\")
			makefile.WriteILine("+", "-MMD -MQ \"$@\" -MF", g.quotePath(cpp_dep), " \\")
			makefile.NewLine()
		} else if f.Is_IXX() {
			makefile.WriteILine("+", g.escapeString(cpp_obj), ":", g.escapeString(cpp_src))
			makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
			makefile.WriteILine("+", "@echo \"[compile ixx] => $@\"")
			makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(PathDirname(cpp_obj)))
			makefile.WriteILine("+", "$(cmd_c) -x $(cpp_source_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) $(CPP_INCLUDE_FILES) \\")
			makefile.WriteILine("+", "-o \"$@\" --precompile", g.quotePath(cpp_src), " \\")
			makefile.WriteILine("+", "-MMD -MQ \"$@\" -MF", g.quotePath(cpp_dep), " \\")
			makefile.NewLine()
		}
	}
	makefile.NewLine()

	//-------------------------------
	makefile.WriteLine("#----- ", config.Type.String(), " output target ----------")

	outputTarget := config.OutputTarget.Path
	outputTargetDir := PathDirname(outputTarget)

	if project.Type.IsExecutable() {
		makefile.WriteILine("+", g.escapeString(outputTarget), ": $(LINK_FILES)")
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[cpp_exe] $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(outputTargetDir))
		makefile.WriteILine("+", "$(cmd_link) -o \"$@\" $(CPP_OBJ_FILES) -lstdc++ -Wl,--start-group $(LINK_FILES) $(LINK_LIB) -Wl,--end-group $(LINK_FLAGS)")
		makefile.NewLine()
		makefile.WriteILine(config.Type.String(), "__run: ", g.escapeString(outputTarget))
		makefile.WriteILine("+", g.quotePath(outputTarget))
		makefile.NewLine()
	} else if project.Type.IsSharedLibrary() {
		makefile.WriteILine("+", g.escapeString(outputTarget), ": $(LINK_FILES)")
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[cpp_dll] $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(outputTargetDir))
		makefile.WriteILine("+", "$(cmd_link) -shared -fPIC -o \"$@\" $(CPP_OBJ_FILES) -lstdc++ -Wl,--start-group $(LINK_FILES) $(LINK_LIB) -Wl,--end-group $(LINK_FLAGS)")
		makefile.NewLine()
		makefile.WriteILine(config.Type.String(), "__run: ", g.escapeString(outputTarget))
		makefile.WriteILine("+", g.quotePath(outputTarget))
		makefile.NewLine()
	} else if project.Type.IsStaticLibrary() {
		makefile.WriteILine("+", g.escapeString(outputTarget), ": $(LINK_FILES)")
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[cpp_lib] $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(outputTargetDir))
		makefile.WriteILine("+", "$(cmd_ar) \"$@\" $(CPP_OBJ_FILES)")
		makefile.NewLine()
		makefile.WriteILine("run_", config.Type.String(), ": ", g.escapeString(outputTarget))
		makefile.WriteILine("+", "@echo cannot run cpp_lib ", g.quotePath(outputTarget))
		makefile.NewLine()
	} else if project.Type.IsExecutable() {
		// nothing to build
	} else {
		fmt.Printf("unknown project.type " + project.Type.String() + "\n")
	}

	makefile.WriteLine("#----- ", config.Type.String(), " output target dependencies ----------")
	makefile.WriteILine(g.escapeString(outputTarget), ":")

	for _, f := range project.FileEntries.Values {
		if f.ExcludedFromBuild {
			continue
		}
		makefile.WriteILine("+", g.escapeString(g.getObjFile(config, f)))
	}
	for _, f := range config.LinkFiles.FinalDict.Values {
		makefile.WriteILine("+", g.quotePath(f))
	}

	makefile.NewLine()
}
