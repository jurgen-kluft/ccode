package axe

import (
	"fmt"
	"path/filepath"
)

type MakeGenerator struct {
	LastGenId  UUID
	Workspace  *Workspace
	VcxProjCpu string
}

func NewMakeGenerator(ws *Workspace) *MakeGenerator {
	g := &MakeGenerator{
		LastGenId: GenerateUUID(),
		Workspace: ws,
	}

	return g
}

func (g *MakeGenerator) Generate() {
	g.generateWorkspace()
}

func (g *MakeGenerator) generateWorkspace() {

	if g.Workspace.StartupProject != nil {
		g.Workspace.StartupProject.GenDataMake.Makefile = filepath.Join(g.Workspace.GenerateAbsPath, "Makefile")
	}

	makefile := NewLineWriter()
	makefile.WriteLine("# generated by ccode::axe")

	g.generateCommonVars(makefile)

	makefile.WriteLine(".PHONY: clean build run")

	for _, project := range g.Workspace.ProjectList.Values {
		g.generateProject(project)
		makefile.NewLine()
		makefile.WriteILine("+", project.Name)
	}

	//----- build: ----------

	makefile.WriteLine("build:")
	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", g.escapeString(project.Name))
	}
	makefile.NewLine()

	makefile.WriteLine("all: build")
	makefile.NewLine()

	makefile.WriteLine("build:")
	makefile.WriteILine("+", "@echo \"--- Build Finished ---\"")
	makefile.NewLine()

	//----- run: ----------

	makefile.WriteLine("run: build")
	makefile.WriteILine("+", "@echo \"==============================================================\"")
	if g.Workspace.StartupProject == nil {
		makefile.WriteILine("+", "@echo \"no startup_project specified\"")
	} else {
		makefile.WriteILine("+", "$(MAKE) -f \"", g.Workspace.StartupProject.GenDataMake.Makefile, "\" run $(MFLAGS)")
	}
	makefile.NewLine()

	//----- clean: ----------

	makefile.WriteLine("clean:")
	makefile.WriteILine("+", "@echo \"==============================================================\"")
	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", "$(MAKE) -f \"", project.GenDataMake.Makefile, "\" clean $(MFLAGS)")
	}
	makefile.WriteILine("+", "@echo \"===== clean finished ===== \"")
	makefile.NewLine()

	// ---- project targets ----

	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", g.escapeString(project.Name), ":")
		for _, dp := range project.Dependencies.Values {
			makefile.WriteILine("+", g.escapeString(dp.Name))
		}
		makefile.NewLine()

		if !project.HasOutputTarget {
			continue
		}

		mtBuild := ""
		if project.Settings.MultiThreadedBuild {
			mtBuild = " -j "
		}

		makefile.WriteILine("\t@echo \"==============================================================\"")
		makefile.WriteILine("\t@echo \"[build project] ", project.Name, "\"")
		makefile.WriteILine("\t$(MAKE)", mtBuild, " -f \"", project.GenDataMake.Makefile, "\" build $(MFLAGS)")
		makefile.NewLine()
	}

	makefile.WriteToFile(g.Workspace.StartupProject.GenDataMake.Makefile)
}

func (g *MakeGenerator) generateCommonVars(makefile *LineWriter) {
	makefile.WriteILine("#!! Unix Makefile")
	makefile.WriteILine("#!! Works wir FreeBSD make or Linux gmake")
	makefile.NewLine()
	makefile.WriteILine("config ?= ", g.Workspace.Configs.DefaultConfigName())
	makefile.NewLine()
	makefile.NewLine()

	if g.Workspace.MakeTarget.OSIsWindows() {
		makefile.WriteILine("cmd_mkdir := cmd.exe /c mkdir.bat")
		makefile.WriteILine("cmd_rmdir := rm -rf")
		makefile.WriteILine("cmd_rm    := rm -f")
		makefile.WriteILine("cmd_copy  := cp -f")
	} else {
		makefile.WriteILine("cmd_mkdir := mkdir -p")
		makefile.WriteILine("cmd_rmdir := rm -rf")
		makefile.WriteILine("cmd_rm    := rm -f")
		makefile.WriteILine("cmd_copy  := cp -f")
	}
	makefile.NewLine()
}

func (g *MakeGenerator) generateProject(project *Project) {
	// if (!proj.hasOutputTarget) return;
	if !project.HasOutputTarget {
		return
	}

	project.GenDataMake.Makefile = filepath.Join(g.Workspace.GenerateAbsPath, project.Name+".make")
	fmt.Printf("generating makefile for project %s\n", project.GenDataMake.Makefile)

	makefile := NewLineWriter()
	g.generateCommonVars(makefile)

	{
		project.PchSuffix = ".gch"
		cppStd := g.Workspace.Config.CppStd
		if g.Workspace.MakeTarget.CompilerIsClang() {
			project.PchSuffix = ".pch"
			makefile.WriteILine("cmd_cpp   := clang++ -std=", cppStd)
			makefile.WriteILine("cmd_c     := clang")
			makefile.WriteILine("cmd_link  := clang++")
		} else if g.Workspace.MakeTarget.CompilerIsGcc() {
			makefile.WriteILine("cmd_cpp   := g++ -std=", cppStd)
			makefile.WriteILine("cmd_c     := gcc")
			makefile.WriteILine("cmd_link  := g++")
		} else {
			panic("Unsupported compiler " + g.Workspace.MakeTarget.CompilerAsString())
		}
		makefile.WriteILine("cmd_ar    := ar rcs")
	}

	if g.Workspace.MakeTarget.OSIsMac() && bool(project.Settings.CppAsObjCpp) {
		makefile.WriteILine("pch_header_compiler_language = objective-c++-header")
		makefile.WriteILine("cpp_source_compiler_language = objective-c++")
		makefile.WriteILine("c_source_compiler_language   = objective-c")
	} else {
		makefile.WriteILine("pch_header_compiler_language = c++-header")
		makefile.WriteILine("cpp_source_compiler_language = c++")
		makefile.WriteILine("c_source_compiler_language   = c")
	}

	makefile.NewLine()
	makefile.WriteLine("pwd = $$(pdw)")
	makefile.NewLine()
	makefile.WriteLine(".PHONY: clean build run")

	makefile.NewLine()

	for _, config := range project.Configs.Values {
		makefile.WriteILine("+", config.Type.String(), "__build")
		makefile.WriteILine("+", config.Type.String(), "__clean")
		makefile.WriteILine("+", config.Type.String(), "__run")
	}
	makefile.NewLine()
	makefile.WriteILine("all: build")
	makefile.NewLine()

	for _, config := range project.Configs.Values {
		g.generateProjectConfig(makefile, project, config)
	}

	makefile.WriteLine("#-----------")
	makefile.WriteILine("BUILD_TMP_DIR      = $($(config)__BUILD_TMP_DIR)")
	makefile.WriteILine("PCH_HEADER_SRC     = $($(config)__PCH_HEADER_SRC)")
	makefile.WriteILine("PCH_HEADER_PCH     = $($(config)__PCH_HEADER_PCH)")
	makefile.WriteILine("PCH_HEADER_DEP     = $($(config)__PCH_HEADER_DEP)")
	makefile.WriteILine("PCH_CC_FLAGS       = $($(config)__PCH_CC_FLAGS)")
	makefile.NewLine()
	makefile.WriteILine("CPP_INCLUDE_DIRS   = $($(config)__CPP_INCLUDE_DIRS)")
	makefile.WriteILine("CPP_INCLUDE_FILES  = $($(config)__CPP_INCLUDE_FILES)")
	makefile.WriteILine("CPP_FLAGS          = $($(config)__CPP_FLAGS)")
	makefile.WriteILine("CPP_DEFINES        = $($(config)__CPP_DEFINES)")
	makefile.WriteILine("C_FLAGS            = $($(config)__C_FLAGS)")
	makefile.WriteILine("C_DEFINES          = $($(config)__C_DEFINES)")
	makefile.WriteILine("LINK_FLAGS         = $($(config)__LINK_FLAGS)")
	makefile.WriteILine("LINK_LIB           = $($(config)__LINK_LIBS)")
	makefile.WriteILine("LINK_FILES         = $($(config)__LINK_FILES)")
	makefile.WriteILine("CPP_OBJ_FILES      = $($(config)__CPP_OBJ_FILES)")
	makefile.NewLine()
	makefile.WriteILine("build: $(config)__build")
	makefile.WriteILine("clean: $(config)__clean")
	makefile.WriteILine("run:   $(config)__run")
	makefile.NewLine()

	makefile.WriteToFile(project.GenDataMake.Makefile)
}

func (g *MakeGenerator) escapeString(s string) string {
	escapedStr := ""
	for _, ch := range s {
		switch ch {
		case ':', ' ':
			escapedStr += "\\" + string(ch)
		default:
			escapedStr += string(ch)
		}
	}
	return escapedStr
}

func (g *MakeGenerator) quotePath(v string) string {
	o := "\""
	if !filepath.IsAbs(v) {
		o += "$(pwd)/"
	}

	for _, ch := range v {
		switch ch {
		case '"':
			o += "\\\""
		default:
			o += string(ch)
		}
	}
	o += "\""
	return o
}

func (g *MakeGenerator) generateProjectConfig(makefile *LineWriter, project *Project, config *Config) {

	makefile.NewLine()
	makefile.NewLine()

	makefile.WriteLine("#===== ", config.Type.String(), " ======================\n")
	makefile.WriteLine("#!!!")
	makefile.WriteLine("#!!! Make cannot handle file paths containing space in a variable")
	makefile.WriteLine("#!!! therefore we unroll all file dependencies directly in this makefile")
	makefile.WriteLine("#!!!")

	config.GenDataMakefile.CppObjDir = filepath.Join(g.Workspace.GenerateAbsPath, "obj", config.Type.String())

	makefile.WriteLine(config.Type.String(), "__build: ", g.escapeString(config.OutputTarget.Path))
	makefile.NewLine()

	makefile.WriteLine(config.Type.String(), "__clean: ")
	makefile.WriteLine()
	makefile.WriteILine("+", "$(cmd_rmdir) \"", config.BuildTmpDir.Path, "\"")
	if len(config.OutputTarget.Path) > 0 {
		makefile.WriteILine("+", "$(cmd_rm) \"", config.OutputTarget.Path, "\"")
	}
	makefile.NewLine()

	pch_header_dep := ""
	pch_header_pch := ""
	pch_header_pch_dir := ""
	pch_basename := ""
	pch_cc_flags := NewLineWriter()

	// //------- pre-compiled header
	// if (proj.pch_header) {
	// 	pch_basename = Path::basename(proj.pch_header->absPath(), true);

	// 	pch_header_pch.set(config._build_tmp_dir.path(), "/cpp_pch/", pch_basename, pch_suffix);
	// 	pch_header_dep.set(pch_header_pch, ".d");

	// 	pch_header_pch_dir = Path::dirname(pch_header_pch);
	// 	pch_cc_flags.append("\\\n\t", "-I", quotePath(pch_header_pch_dir));
	// 	pch_cc_flags.append("\\\n\t", "-include ", quotePath(proj.pch_header->path()));

	// 	//makefile optional include cpp_dep
	// 	o.append("-include ", escapeString(pch_header_dep), "\n");
	// 	//---------
	// 	o.append("#--- pch_header dependencies ------\n");
	// 	o.append(escapeString(pch_header_pch), ": ", escapeString(proj.pch_header->path()), "\n");
	// 	o.append("\t@echo \"-------------------------------------------------------------\"\n");
	// 	o.append("\t@echo \"[precompiled header] $< => $@\"\n");
	// 	o.append("\t$(cmd_mkdir) ", quotePath(pch_header_pch_dir), "\n");
	// 	o.append("\t$(cmd_cpp) -x $(pch_header_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) \\\n");
	// 	o.append("\t\t-o \"$@\" -c ", quotePath(proj.pch_header->path()), " \\\n");
	// 	o.append("\t\t-MMD -MQ \"$@\" -MF ", quotePath(pch_header_dep), " \\\n");
	// 	o.append("\n");

	// 	o.append("\n\n");
	// }

	//------- pre-compiled header

	if project.PchHeader != nil {
		pch_basename = PathFilename(project.PchHeader.Path, true)

		pch_header_pch = filepath.Join(config.BuildTmpDir.Path, "pch", pch_basename, project.PchSuffix)
		pch_header_dep = pch_header_pch + ".d"

		pch_header_pch_dir = PathDirname(pch_header_pch)

		pch_cc_flags.WriteILine("+", "-I", g.quotePath(pch_header_pch_dir))
		pch_cc_flags.WriteILine("+", "-include", g.quotePath(project.PchHeader.Path))

		// makefile optional include cpp_dep
		makefile.WriteLine("-include", g.escapeString(pch_header_dep))
		// --------

	}

}
