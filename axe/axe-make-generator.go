package axe

import (
	"fmt"
	"path/filepath"
)

type MakeGenerator struct {
	Workspace  *Workspace
	VcxProjCpu string
}

func NewMakeGenerator(ws *Workspace) *MakeGenerator {
	g := &MakeGenerator{
		Workspace: ws,
	}

	return g
}

func (g *MakeGenerator) Generate() {
	g.generateWorkspace()
}

func (g *MakeGenerator) generateWorkspace() {

	if g.Workspace.StartupProject != nil {
		g.Workspace.StartupProject.GenDataMake.Makefile = filepath.Join(g.Workspace.GenerateAbsPath, "Makefile")
	}

	makefile := NewLineWriter(IndentModeTabs)

	makefile.WriteLine("# generated by ccode::axe")

	g.generateCommonVars(makefile)

	makefile.WriteLine(".PHONY: \\")
	makefile.WriteLine("clean \\")
	makefile.WriteLine("build \\")
	makefile.Write("run")

	for i, project := range g.Workspace.ProjectList.Values {
		if i == 0 {
			makefile.WriteLine(" \\")
		}

		g.generateProject(project)
		if i < len(g.Workspace.ProjectList.Values)-1 {
			makefile.WriteLine(project.Name, " \\")
		} else {
			makefile.WriteLine(project.Name)
		}
	}
	makefile.NewLine()

	//----- build: ----------

	makefile.WriteLine("build: \\")
	for i, project := range g.Workspace.ProjectList.Values {
		if i < len(g.Workspace.ProjectList.Values)-1 {
			makefile.WriteILine("+", g.escapeString(project.Name), "\\")
		} else {
			makefile.WriteILine("+", g.escapeString(project.Name))
		}
	}
	makefile.NewLine()

	makefile.WriteLine("all: build")
	makefile.NewLine()

	makefile.WriteLine("build: ")
	makefile.WriteILine("+", "@echo \"--- Build Finished ---\"")
	makefile.NewLine()

	//----- run: ----------

	makefile.WriteLine("run: build")
	makefile.WriteILine("+", "@echo \"==============================================================\"")
	if g.Workspace.StartupProject == nil {
		makefile.WriteILine("+", "@echo \"no startup_project specified\"")
	} else {
		makefile.WriteILine("+", "$(MAKE) -f \"", g.Workspace.StartupProject.GenDataMake.Makefile, "\" run $(MFLAGS)")
	}
	makefile.NewLine()

	//----- clean: ----------

	makefile.WriteLine("clean:")
	makefile.WriteILine("+", "@echo \"==============================================================\"")
	for _, project := range g.Workspace.ProjectList.Values {
		makefile.WriteILine("+", "$(MAKE) -f \"", project.GenDataMake.Makefile, "\" clean $(MFLAGS)")
	}
	makefile.WriteILine("+", "@echo \"===== clean finished ===== \"")
	makefile.NewLine()

	// ---- project targets ----

	for _, project := range g.Workspace.ProjectList.Values {
		makefile.Write(g.escapeString(project.Name), ":")
		for _, dp := range project.Dependencies.Values {
			makefile.Write(" ", g.escapeString(dp.Name))
		}
		makefile.NewLine()

		if !project.HasOutputTarget {
			continue
		}

		mtBuild := ""
		if project.Settings.MultiThreadedBuild {
			mtBuild = " -j "
		}

		makefile.WriteILine("+", "@echo \"==============================================================\"")
		makefile.WriteILine("+", "@echo \"[build project] ", project.Name, "\"")
		makefile.WriteILine("+", "$(MAKE)", mtBuild, " -f \"", project.GenDataMake.Makefile, "\" build $(MFLAGS)")
		makefile.NewLine()
	}

	makefile.WriteToFile(filepath.Join(g.Workspace.GenerateAbsPath, "GNUmakefile"))

	bsdmakefile := NewLineWriter(IndentModeTabs)
	bsdmakefile.WriteLine(".PHONY: all clean build run: ")
	bsdmakefile.WriteLine("all clean build run: ")
	bsdmakefile.WriteILine("+", "gmake $@ $(MFLAGS)")
	bsdmakefile.WriteToFile(filepath.Join(g.Workspace.GenerateAbsPath, "Makefile"))
}

func (g *MakeGenerator) generateCommonVars(makefile *LineWriter) {
	makefile.WriteLine("#!! Unix Makefile")
	makefile.WriteLine("#!! Works with FreeBSD make or Linux gmake")
	makefile.NewLine()
	makefile.WriteLine("config ?= ", g.Workspace.Configs.DefaultConfigName())
	makefile.NewLine()

	if g.Workspace.MakeTarget.OSIsWindows() {
		makefile.WriteLine("cmd_mkdir := cmd.exe /c mkdir.bat")
		makefile.WriteLine("cmd_rmdir := rm -rf")
		makefile.WriteLine("cmd_rm    := rm -f")
		makefile.WriteLine("cmd_copy  := cp -f")
	} else {
		makefile.WriteLine("cmd_mkdir := mkdir -p")
		makefile.WriteLine("cmd_rmdir := rm -rf")
		makefile.WriteLine("cmd_rm    := rm -f")
		makefile.WriteLine("cmd_copy  := cp -f")
	}
	makefile.NewLine()
}

func (g *MakeGenerator) generateProject(project *Project) {
	if !project.HasOutputTarget {
		return
	}

	project.GenDataMake.Makefile = filepath.Join(g.Workspace.GenerateAbsPath, project.Name+".make")
	fmt.Printf("generating makefile for project %s\n", project.GenDataMake.Makefile)

	makefile := NewLineWriter(IndentModeTabs)

	g.generateCommonVars(makefile)

	{
		project.PchSuffix = ".gch"
		cppStd := g.Workspace.Config.CppStd
		if g.Workspace.MakeTarget.CompilerIsClang() {
			project.PchSuffix = ".pch"
			makefile.WriteLine("cmd_cpp   := clang++ -std=", cppStd)
			makefile.WriteLine("cmd_c     := clang")
			makefile.WriteLine("cmd_link  := clang++")
		} else if g.Workspace.MakeTarget.CompilerIsGcc() {
			makefile.WriteLine("cmd_cpp   := g++ -std=", cppStd)
			makefile.WriteLine("cmd_c     := gcc")
			makefile.WriteLine("cmd_link  := g++")
		} else {
			fmt.Printf("Unsupported compiler " + g.Workspace.MakeTarget.CompilerAsString() + "\n")
		}
		makefile.WriteLine("cmd_ar    := ar rcs")
	}

	if g.Workspace.MakeTarget.OSIsMac() && bool(project.Settings.CppAsObjCpp) {
		makefile.WriteLine("pch_header_compiler_language = objective-c++-header")
		makefile.WriteLine("cpp_source_compiler_language = objective-c++")
		makefile.WriteLine("c_source_compiler_language   = objective-c")
	} else {
		makefile.WriteLine("pch_header_compiler_language = c++-header")
		makefile.WriteLine("cpp_source_compiler_language = c++")
		makefile.WriteLine("c_source_compiler_language   = c")
	}

	makefile.NewLine()
	makefile.WriteLine("pwd = $$(pwd)")
	makefile.NewLine()
	makefile.WriteLine(".PHONY: \\")
	makefile.WriteILine("+", "clean \\")
	makefile.WriteILine("+", "build \\")
	makefile.WriteILine("+", "run \\")
	lineEnd := " \\"
	for line, config := range project.Configs.Values {
		makefile.WriteILine("+", config.Type.String(), "__build", lineEnd)
		makefile.WriteILine("+", config.Type.String(), "__clean", lineEnd)
		if line == len(project.Configs.Values)-1 {
			lineEnd = ""
		}
		makefile.WriteILine("+", config.Type.String(), "__run", lineEnd)
	}
	makefile.NewLine()
	makefile.WriteLine("all: build")
	makefile.NewLine()

	for _, config := range project.Configs.Values {
		g.generateProjectConfig(makefile, project, config)
	}

	makefile.WriteLine("#-----------")
	makefile.WriteLine("BUILD_TMP_DIR      = $($(config)__BUILD_TMP_DIR)")
	makefile.WriteLine("PCH_HEADER_SRC     = $($(config)__PCH_HEADER_SRC)")
	makefile.WriteLine("PCH_HEADER_PCH     = $($(config)__PCH_HEADER_PCH)")
	makefile.WriteLine("PCH_HEADER_DEP     = $($(config)__PCH_HEADER_DEP)")
	makefile.WriteLine("PCH_CC_FLAGS       = $($(config)__PCH_CC_FLAGS)")
	makefile.NewLine()
	makefile.WriteLine("CPP_INCLUDE_DIRS   = $($(config)__CPP_INCLUDE_DIRS)")
	makefile.WriteLine("CPP_INCLUDE_FILES  = $($(config)__CPP_INCLUDE_FILES)")
	makefile.WriteLine("CPP_FLAGS          = $($(config)__CPP_FLAGS)")
	makefile.WriteLine("CPP_DEFINES        = $($(config)__CPP_DEFINES)")
	makefile.WriteLine("C_FLAGS            = $($(config)__C_FLAGS)")
	makefile.WriteLine("C_DEFINES          = $($(config)__C_DEFINES)")
	makefile.WriteLine("LINK_FLAGS         = $($(config)__LINK_FLAGS)")
	makefile.WriteLine("LINK_LIB           = $($(config)__LINK_LIBS)")
	makefile.WriteLine("LINK_FILES         = $($(config)__LINK_FILES)")
	makefile.WriteLine("CPP_OBJ_FILES      = $($(config)__CPP_OBJ_FILES)")
	makefile.NewLine()
	makefile.WriteLine("build: $(config)__build")
	makefile.WriteLine("clean: $(config)__clean")
	makefile.WriteLine("run:   $(config)__run")
	makefile.NewLine()

	makefile.WriteToFile(project.GenDataMake.Makefile)
}

func (g *MakeGenerator) escapeString(s string) string {
	escapedStr := ""
	for _, ch := range s {
		switch ch {
		case ':', ' ':
			escapedStr += "\\" + string(ch)
		default:
			escapedStr += string(ch)
		}
	}
	return escapedStr
}

func (g *MakeGenerator) quotePath(v string) string {
	o := "\""
	// if !filepath.IsAbs(v) {
	// 	o += "$(pwd)/"
	// }

	for _, ch := range v {
		switch ch {
		case '"':
			o += "\\\""
		default:
			o += string(ch)
		}
	}
	o += "\""
	return o
}

//	String Generator_makefile::get_obj_file(Config& config, FileEntry& f) {
//		return String(config.genData_makefile.cpp_obj_dir, Path::basename(f.path(), true), "_obj");
//	}
func (g *MakeGenerator) getObjFile(config *Config, f *FileEntry) string {
	path := filepath.Join(config.GenDataMakefile.CppObjDir, PathFilename(f.Path, true)+".o")
	return path
}

func (g *MakeGenerator) generateProjectConfig(makefile *LineWriter, project *Project, config *Config) {
	makefile.WriteLine("#===== ", config.Type.String(), " ======================\n")
	makefile.WriteLine("#!!!")
	makefile.WriteLine("#!!! Make cannot handle file paths containing space in a variable")
	makefile.WriteLine("#!!! therefore we unroll all file dependencies directly in this makefile")
	makefile.WriteLine("#!!!")

	config.GenDataMakefile.CppObjDir = filepath.Join("obj", project.Name, config.Type.String())
	buildTempRelDir := PathGetRel(config.BuildTmpDir.Path, g.Workspace.GenerateAbsPath)

	makefile.WriteLine(config.Type.String(), "__build: ", g.escapeString(PathGetRel(config.OutputTarget.Path, g.Workspace.GenerateAbsPath)))
	makefile.NewLine()

	makefile.WriteLine(config.Type.String(), "__clean: ")
	if len(config.OutputTarget.Path) > 0 {
		makefile.WriteILine("+", "$(cmd_rmdir) \"", buildTempRelDir, "\"")
		makefile.WriteILine("+", "$(cmd_rm) \"", PathGetRel(config.OutputTarget.Path, g.Workspace.GenerateAbsPath), "\"")
	} else {
		makefile.WriteILine("+", "$(cmd_rmdir) \"", buildTempRelDir, "\"")
	}
	makefile.NewLine()

	pch_header_relpath := ""
	if project.PchHeader != nil {
		pch_header_relpath = PathGetRel(project.PchHeader.Path, g.Workspace.GenerateAbsPath)
	}

	pch_header_reldep := ""
	pch_header_relpch := ""
	pch_header_pch_reldir := ""
	pch_basename := ""
	pch_cc_flags := NewLineWriter(IndentModeTabs)

	//------- pre-compiled header

	if project.PchHeader != nil {
		pch_basename = PathFilename(project.PchHeader.Path, true)

		pch_header_relpch = filepath.Join(buildTempRelDir, "pch", pch_basename+project.PchSuffix)
		pch_header_reldep = pch_header_relpch + ".d"

		pch_header_pch_reldir = PathDirname(pch_header_relpch)

		pch_cc_flags.WriteILine("+", "-I", g.quotePath(pch_header_pch_reldir))
		pch_cc_flags.WriteILine("+", "-include", g.quotePath(pch_header_relpath))

		// makefile optional include cpp_dep
		makefile.WriteLine("-include", g.escapeString(pch_header_reldep))
		// --------
		makefile.WriteLine("#--- pch_header dependencies ------")
		makefile.WriteILine("+", g.escapeString(pch_header_relpch), ":", g.escapeString(pch_header_relpath))
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[precompiled header] $< => $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir)", g.quotePath(pch_header_pch_reldir))
		makefile.WriteILine("+", "$(cmd_cpp) -x $(pch_header_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) \\")
		makefile.WriteILine("++", "-o \"$@\" -c ", g.quotePath(pch_header_relpath), " \\")
		makefile.WriteILine("++", "-MMD -MQ \"$@\" -MF", g.quotePath(pch_header_reldep), " \\")
		makefile.NewLine()
		makefile.NewLine()
	}

	makefile.WriteLine("#-----------------------")

	lineEnd := []string{" \\", ""}

	cpp_defines := NewLineWriter(IndentModeTabs)
	cpp_flags := NewLineWriter(IndentModeTabs)
	link_flags := NewLineWriter(IndentModeTabs)
	link_libs := NewLineWriter(IndentModeTabs)
	link_files := NewLineWriter(IndentModeTabs)
	include_files := NewLineWriter(IndentModeTabs)
	include_dirs := NewLineWriter(IndentModeTabs)
	cpp_obj_files := NewLineWriter(IndentModeTabs)

	config.CppDefines.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		cpp_defines.WriteILine("+", "-D", value, lineEnd[last])
	})
	config.CppFlags.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		cpp_flags.WriteILine("+", value, lineEnd[last])
	})
	config.LinkFlags.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		link_flags.WriteILine("+", value, lineEnd[last])
	})
	config.LinkDirs.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		link_libs.WriteILine("+", "-L", g.quotePath(value), lineEnd[last])
	})
	config.LinkLibs.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		link_libs.WriteILine("+", "-l", value, lineEnd[last])
	})
	config.LinkFiles.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		link_files.WriteILine("+", g.quotePath(value), lineEnd[last])
	})
	config.IncludeFiles.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		path := PathGetRel(key, g.Workspace.GenerateAbsPath)
		include_files.WriteILine("+", "-include", g.quotePath(path), lineEnd[last])
	})
	config.IncludeDirs.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		path := PathGetRel(key, g.Workspace.GenerateAbsPath)
		include_dirs.WriteILine("+", "-I", g.quotePath(path), lineEnd[last])
	})

	excludedFromBuildFilter := func(f *FileEntry) bool { return !f.ExcludedFromBuild }
	project.FileEntries.Enumerate(excludedFromBuildFilter, func(i int, key string, value *FileEntry, last int) {
		cpp_obj_files.WriteILine("+", g.escapeString(g.getObjFile(config, value)), lineEnd[last])
	})

	makefile.WriteLine(config.Type.String(), "__BUILD_TMP_DIR  = ", g.escapeString(buildTempRelDir))
	if project.PchHeader != nil {
		makefile.WriteLine(config.Type.String(), "__PCH_HEADER        = ", g.quotePath(pch_header_relpath))
		makefile.WriteLine(config.Type.String(), "__PCH_HEADER_PCH    = ", g.quotePath(pch_header_relpch))
		makefile.WriteLine(config.Type.String(), "__PCH_HEADER_DEP    = ", g.quotePath(pch_header_reldep))
	}

	if !pch_cc_flags.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__PCH_CC_FLAGS      = \\")
		makefile.Append(pch_cc_flags)
		makefile.NewLine()
	}

	if !include_dirs.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__CPP_INCLUDE_DIRS  = \\")
		makefile.Append(include_dirs)
		makefile.NewLine()
	}

	if !include_files.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__CPP_INCLUDE_FILES = \\")
		makefile.Append(include_files)
		makefile.NewLine()
	}

	if !cpp_flags.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__CPP_FLAGS         = \\")
		makefile.Append(cpp_flags)
		makefile.NewLine()
	}

	if !cpp_defines.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__CPP_DEFINES       = \\")
		makefile.Append(cpp_defines)
		makefile.NewLine()
	}

	if !link_flags.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__LINK_FLAGS        = \\")
		makefile.Append(link_flags)
		makefile.NewLine()
	}

	if !link_libs.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__LINK_LIBS         = \\")
		makefile.Append(link_libs)
		makefile.NewLine()
	}

	if !link_files.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__LINK_FILES        = \\")
		makefile.Append(link_files)
		makefile.NewLine()
	}

	if !cpp_obj_files.IsEmpty() {
		makefile.WriteLine(config.Type.String(), "__CPP_OBJ_FILES     = \\")
		makefile.Append(cpp_obj_files)
		makefile.NewLine()
	}

	makefile.WriteLine("#--- ", config.Type.String(), " cpp_obj dependencies ------")

	for _, f := range project.FileEntries.Values {
		if f.ExcludedFromBuild {
			continue
		}

		cpp_obj := g.getObjFile(config, f)
		cpp_dep := cpp_obj + ".d"
		cpp_src := PathGetRel(filepath.Join(project.ProjectAbsPath, f.Path), g.Workspace.GenerateAbsPath)

		if f.Is_C() {
			makefile.WriteLine("-include ", g.escapeString(cpp_dep), "")
			makefile.WriteLine(g.escapeString(cpp_obj), ":", g.escapeString(cpp_src), "")
			makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"", " ")
			makefile.WriteILine("+", "@echo \"[compile c] => $@\"", " ")
			makefile.WriteILine("+", "$(cmd_mkdir) ", g.quotePath(PathDirname(cpp_obj)), " ")
			makefile.WriteILine("+", "$(cmd_c) -x $(c_source_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) $(CPP_INCLUDE_FILES) \\")
			makefile.WriteILine("++", "-o \"$@\" -c ", g.quotePath(cpp_src), " \\")
			makefile.WriteILine("++", "-MMD -MQ \"$@\" -MF", g.quotePath(cpp_dep), " \\")
			makefile.NewLine()
		} else if f.Is_CPP() {
			if project.PchHeader != nil {
				makefile.WriteLine(g.escapeString(cpp_obj), ": ", g.escapeString(pch_header_relpch))
			}
			makefile.WriteLine("-include ", g.escapeString(cpp_dep), " ")
			makefile.WriteLine(g.escapeString(cpp_obj), ":", g.escapeString(cpp_src), " ")
			makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"", " ")
			makefile.WriteILine("+", "@echo \"[compile cpp] => $@\"", " ")
			makefile.WriteILine("+", "$(cmd_mkdir) ", g.quotePath(PathDirname(cpp_obj)), " ")
			makefile.WriteILine("+", "$(cmd_cpp) -x $(cpp_source_compiler_language) $(PCH_CC_FLAGS) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) $(CPP_INCLUDE_FILES) \\")
			makefile.WriteILine("++", "-o \"$@\" -c ", g.quotePath(cpp_src), " \\")
			makefile.WriteILine("++", "-MMD -MQ \"$@\" -MF", g.quotePath(cpp_dep), " \\")
			makefile.NewLine()
		} else if f.Is_IXX() {
			makefile.WriteLine(g.escapeString(cpp_obj), ":", g.escapeString(cpp_src), " ")
			makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"", " ")
			makefile.WriteILine("+", "@echo \"[compile ixx] => $@\"", " ")
			makefile.WriteILine("+", "$(cmd_mkdir) ", g.quotePath(PathDirname(cpp_obj)), " ")
			makefile.WriteILine("+", "$(cmd_c) -x $(cpp_source_compiler_language) $(CPP_DEFINES) $(CPP_FLAGS) $(CPP_INCLUDE_DIRS) $(CPP_INCLUDE_FILES) \\")
			makefile.WriteILine("++", "-o \"$@\" --precompile", g.quotePath(cpp_src), " \\")
			makefile.WriteILine("++", "-MMD -MQ \"$@\" -MF", g.quotePath(cpp_dep), " \\")
			makefile.NewLine()
		}
	}
	makefile.NewLine()

	//-------------------------------
	makefile.WriteLine("#----- ", config.Type.String(), " output target ----------")

	outputTarget := PathGetRel(config.OutputTarget.Path, g.Workspace.GenerateAbsPath)
	outputTargetDir := PathDirname(outputTarget)

	if project.Type.IsExecutable() {
		makefile.WriteLine(g.escapeString(outputTarget), ": $(LINK_FILES)")
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[cpp_exe] $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir) ", g.quotePath(outputTargetDir))
		//makefile.WriteILine("+", "$(cmd_link) -o \"$@\" $(CPP_OBJ_FILES) -lstdc++ -Wl,--start-group $(LINK_FILES) $(LINK_LIB) -Wl,--end-group $(LINK_FLAGS)")
		makefile.WriteILine("+", "$(cmd_link) -o \"$@\" $(CPP_OBJ_FILES) -lstdc++ $(LINK_FILES) $(LINK_LIB) $(LINK_FLAGS)")
		makefile.NewLine()
		makefile.WriteLine(config.Type.String(), "__run: ", g.escapeString(outputTarget))
		makefile.WriteILine("+", g.quotePath(outputTarget))
		makefile.NewLine()
	} else if project.Type.IsSharedLibrary() {
		makefile.WriteLine(g.escapeString(outputTarget), ": $(LINK_FILES)")
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[cpp_dll] $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir) ", g.quotePath(outputTargetDir))
		makefile.WriteILine("+", "$(cmd_link) -shared -fPIC -o \"$@\" $(CPP_OBJ_FILES) -lstdc++ -Wl,--start-group $(LINK_FILES) $(LINK_LIB) -Wl,--end-group $(LINK_FLAGS)")
		makefile.NewLine()
		makefile.WriteLine(config.Type.String(), "__run: ", g.escapeString(outputTarget))
		makefile.WriteILine("+", g.quotePath(outputTarget))
		makefile.NewLine()
	} else if project.Type.IsStaticLibrary() {
		makefile.WriteLine(g.escapeString(outputTarget), ": $(LINK_FILES)")
		makefile.WriteILine("+", "@echo \"-------------------------------------------------------------\"")
		makefile.WriteILine("+", "@echo \"[cpp_lib] $@\"")
		makefile.WriteILine("+", "$(cmd_mkdir) ", g.quotePath(outputTargetDir))
		makefile.WriteILine("+", "$(cmd_ar) \"$@\" $(CPP_OBJ_FILES)")
		makefile.NewLine()
		makefile.WriteLine("run_", config.Type.String(), ": ", g.escapeString(outputTarget))
		makefile.WriteILine("+", "@echo cannot run cpp_lib ", g.quotePath(outputTarget))
		makefile.NewLine()
	} else if project.Type.IsExecutable() {
		// nothing to build
	} else {
		fmt.Printf("unknown project.type " + project.Type.String() + "\n")
	}

	makefile.WriteLine("#----- ", config.Type.String(), " output target dependencies ----------")
	makefile.WriteLine(g.escapeString(outputTarget), ":\\")

	// Collect all the link files and output them in the makefile
	linkfiles := []string{}
	project.FileEntries.Enumerate(excludedFromBuildFilter, func(i int, key string, value *FileEntry, last int) {
		linkfiles = append(linkfiles, g.escapeString(g.getObjFile(config, value)))
	})
	config.LinkFiles.FinalDict.Enumerate(func(i int, key string, value string, last int) {
		path := PathGetRel(value, g.Workspace.GenerateAbsPath)
		linkfiles = append(linkfiles, path)
	})
	for i, linkfile := range linkfiles {
		if i < len(linkfiles)-1 {
			makefile.WriteILine("+", linkfile, " \\")
		} else {
			makefile.WriteILine("+", linkfile)
		}
	}

	makefile.NewLine()
}
